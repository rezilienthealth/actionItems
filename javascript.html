<script>
    // Global variables
    let actionItems = [];
    let actionItemOptions = {};
    let currentUser = '';
    let userRole = 'User';
    let currentActionItemId = null; // Global variable for action item ID
    let allUsers = []; // For admin functionality
    let allGroups = []; // For admin functionality
    let currentTab = 'my-items'; // Current active tab
    
    function clearServerCache() {
      console.log('Attempting to clear server cache...');
      google.script.run
        .withSuccessHandler(function(message) {
          console.log(message);
          alert('Server cache cleared. Please hard-refresh the page now (Cmd+Shift+R or Ctrl+Shift+R) and try again.');
          // Force a reload of the options from the server
          loadActionItemOptions(true);
        })
        .withFailureHandler(function(error) {
          console.error('Failed to clear server cache:', error.message);
          alert('Error clearing server cache: ' + error.message);
        })
        .clearActionItemOptionsCache();
    }

    // Initialize the application
    document.addEventListener('DOMContentLoaded', function() {
      loadActionItems();
      loadActionItemOptions();
      loadUsers();
      loadNotificationGroups();
      loadUsersForMentions(); // Load users for mentions autocomplete

      // Set user role (currentUser will be set in renderActionItems)
      userRole = document.getElementById('user-role').dataset.role;
      
      // Initialize tab navigation
      initTabs();
      
      // Initialize admin functionality
      initAdmin();
      
      // Initialize modal functionality
      initModal();
      
      // Load data
      loadActionItems();
      
      // Initialize event listeners
      initEventListeners();

      // This listener handles changes for all current and future category dropdowns
      document.body.addEventListener('change', function(event) {
        if (event.target.matches('.category-dropdown')) {
          handleCategoryChange(event);
        }
      });
    });
    
    // Initialize tab navigation
    function initTabs() {
      const tabButtons = document.querySelectorAll('.tab-button');
      
      tabButtons.forEach(button => {
        button.addEventListener('click', function() {
          const tabId = this.dataset.tab;
          
          // Update active tab button
          tabButtons.forEach(btn => btn.classList.remove('active'));
          this.classList.add('active');
          
          // Update active tab content
          document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.remove('active');
          });
          
          // Handle admin tab special case
          const contentId = tabId === 'admin' ? 'admin-content' : tabId + '-tab';
          const contentElement = document.getElementById(contentId);
          if (contentElement) {
            contentElement.classList.add('active');
          }
          
          // Update current tab
          currentTab = tabId;
          
          // Refresh data if needed
          if (tabId === 'my-items' || tabId === 'all-items') {
            loadActionItems();
          } else if (tabId === 'activity-feed') {
            loadActivityFeed();
          } else if (tabId === 'templates') {
            loadTemplates();
          } else if (tabId === 'admin') {
            // Load admin data when admin tab is opened
            setTimeout(() => {
              loadUsers();
              loadGroups();
            }, 100);
          }
        });
      });
    }
    
    // Initialize modal functionality
    function initModal() {
      const modal = document.getElementById('item-modal');
      const closeBtn = document.querySelector('.close-modal');
      const cancelBtn = document.getElementById('cancel-item-btn');
      
      closeBtn.addEventListener('click', closeModal);
      cancelBtn.addEventListener('click', closeModal);
      
      window.addEventListener('click', function(event) {
        if (event.target === modal) {
          closeModal();
        }
      });
      
      // Initialize form submission
      document.getElementById('item-form').addEventListener('submit', function(event) {
        event.preventDefault();
        saveActionItem();
      });
    }
    
    // Close modal
    function closeModal() {
      // Hide the modal
      const modal = document.getElementById('item-modal');
      if (modal) {
        modal.style.display = 'none';
      }
      
      // Reset modal state
      currentActionItemId = null;
      
      // Show form and hide comments section by default
      const form = document.getElementById('new-item-form');
      const commentsSection = document.querySelector('.item-details-section');
      
      if (form) form.style.display = 'block';
      if (commentsSection) commentsSection.style.display = 'none';
      
      // Reset modal title
      const title = document.getElementById('modal-title');
      if (title) title.textContent = 'Action Item Details';
      
      // Clear form fields
      const formElement = document.getElementById('new-item-form');
      if (formElement) {
        formElement.reset();
      }
      
      // Clear comments
      const commentsContainer = document.getElementById('comments-container');
      if (commentsContainer) {
        commentsContainer.innerHTML = '';
      }
      
      // Clear new comment textarea
      const newCommentTextarea = document.getElementById('new-comment');
      if (newCommentTextarea) {
        newCommentTextarea.value = '';
      }
    }
    
    // Global helper function to safely add event listeners
    function safeAddEventListener(selector, event, handler) {
      const element = typeof selector === 'string' ? document.getElementById(selector) : selector;
      if (element) {
        element.addEventListener(event, handler);
        return true;
      }
      return false;
    }

    // Initialize event listeners
    function initEventListeners() {

      // New action item buttons - only add if elements exist
      safeAddEventListener('new-item-btn', 'click', openNewItemModal);
      safeAddEventListener('new-item-btn-all', 'click', openNewItemModal);
      safeAddEventListener('new-template-btn', 'click', openNewTemplateModal);
      
      // Add debug button for viewing logs
      const debugButton = document.createElement('button');
      debugButton.textContent = 'View Server Logs';
      debugButton.style.position = 'fixed';
      debugButton.style.bottom = '10px';
      debugButton.style.right = '10px';
      
      // My Items filter listeners
      safeAddEventListener('assignment-filter', 'change', applyAdvancedFilters);
      safeAddEventListener('created-by-filter', 'change', applyAdvancedFilters);
      safeAddEventListener('status-filter', 'change', applyAdvancedFilters);
      safeAddEventListener('priority-filter', 'change', applyAdvancedFilters);
      safeAddEventListener('due-date-filter', 'change', applyAdvancedFilters);
      safeAddEventListener('category-filter', 'change', applyAdvancedFilters);
      safeAddEventListener('search-input', 'input', applyAdvancedFilters);
      safeAddEventListener('clear-filters-btn', 'click', clearAllFilters);
      
      // All Items filter listeners
      safeAddEventListener('assignment-filter-all', 'change', renderActionItems);
      safeAddEventListener('created-by-filter-all', 'change', renderActionItems);
      safeAddEventListener('status-filter-all', 'change', renderActionItems);
      safeAddEventListener('priority-filter-all', 'change', renderActionItems);
      safeAddEventListener('due-date-filter-all', 'change', renderActionItems);
      safeAddEventListener('category-filter-all', 'change', renderActionItems);
      safeAddEventListener('search-input-all', 'input', renderActionItems);
      safeAddEventListener('clear-filters-btn-all', 'click', clearAllFiltersAll);
      
      // Add comment button
      safeAddEventListener('add-comment-btn', 'click', addComment);
      
      // Activity feed event listeners
      safeAddEventListener('refresh-feed-btn', 'click', loadActivityFeed);
      safeAddEventListener('clear-feed-filters-btn', 'click', clearActivityFeedFilters);
      
      // Activity feed filter change listeners
      safeAddEventListener('feed-filter-type', 'change', loadActivityFeed);
      safeAddEventListener('feed-filter-user', 'change', loadActivityFeed);
      safeAddEventListener('feed-filter-date', 'change', loadActivityFeed);
      
      // Comment submission
      const commentInput = document.getElementById('comment-input');
      if (commentInput) {
        commentInput.addEventListener('keydown', handleCommentKeyDown);
      }
      
      // Close modals when clicking the X button
      document.querySelectorAll('.close').forEach(button => {
        button.addEventListener('click', function() {
          const modal = this.closest('.modal');
          if (modal) modal.style.display = 'none';
        });
      });
      
      // Click outside modal to close
      window.addEventListener('click', function(event) {
        if (event.target.classList.contains('modal')) {
          event.target.style.display = 'none';
        }
      });
      
      // Event delegation for action item buttons
      safeAddEventListener('my-items-container', 'click', handleActionItemClick);
      safeAddEventListener('all-items-container', 'click', handleActionItemClick);
      
      // Initialize mentions autocomplete
      initializeMentionsOnAllFields();
      
      // Initialize admin tab if it exists
      if (document.getElementById('admin-tab')) {
        initAdmin();
      }
      
      renderActionItems();
    }
    
    // Populate assignment filter with users who have actions assigned to them
    function populateAssignmentFilter() {
      const assignmentFilter = document.getElementById('assignment-filter');
      const assignmentFilterAll = document.getElementById('assignment-filter-all');
      if (!actionItems) return;
      
      // Get unique assigned users
      const assignedUsers = new Set();
      actionItems.forEach(item => {
        if (item.assignedTo && item.assignedTo.trim()) {
          assignedUsers.add(item.assignedTo.trim());
        }
      });
      
      // Update My Items assignment filter
      if (assignmentFilter) {
        // Clear and rebuild with base options first
        assignmentFilter.innerHTML = `
          <option value="all">All Assignments</option>
          <option value="assigned-to-me">Assigned to Me</option>
          <option value="unassigned">Unassigned</option>
          <option value="assigned-to-others">Assigned to Others</option>
        `;
        // Add user-specific options
        Array.from(assignedUsers).sort().forEach(user => {
          const option = document.createElement('option');
          option.value = user;
          option.textContent = `Assigned to ${user}`;
          assignmentFilter.appendChild(option);
        });
      }
      
      // Update All Items assignment filter
      if (assignmentFilterAll) {
        assignmentFilterAll.innerHTML = '<option value="all">All Assignments</option>';
        Array.from(assignedUsers).sort().forEach(user => {
          const option = document.createElement('option');
          option.value = user;
          option.textContent = `Assigned to ${user}`;
          assignmentFilterAll.appendChild(option);
        });
      }
      
      console.log('Populated assignment filters with', assignedUsers.size, 'users:', Array.from(assignedUsers));
    }
    
    // Populate created-by filter with users who have created actions
    function populateCreatedByFilter() {
      const createdByFilter = document.getElementById('created-by-filter');
      const createdByFilterAll = document.getElementById('created-by-filter-all');
      if (!actionItems) return;
      
      // Get unique creators
      const creators = new Set();
      actionItems.forEach(item => {
        if (item.createdBy && item.createdBy.trim()) {
          creators.add(item.createdBy.trim());
        }
      });
      
      // Update My Items created-by filter
      if (createdByFilter) {
        createdByFilter.innerHTML = '<option value="all">All Creators</option>';
        Array.from(creators).sort().forEach(creator => {
          const option = document.createElement('option');
          option.value = creator;
          option.textContent = `Created by ${creator}`;
          createdByFilter.appendChild(option);
        });
      }
      
      // Update All Items created-by filter
      if (createdByFilterAll) {
        createdByFilterAll.innerHTML = '<option value="all">All Creators</option>';
        Array.from(creators).sort().forEach(creator => {
          const option = document.createElement('option');
          option.value = creator;
          option.textContent = `Created by ${creator}`;
          createdByFilterAll.appendChild(option);
        });
      }
      
      console.log('Populated created-by filters with', creators.size, 'creators:', Array.from(creators));
    }
    
    // Populate category filter with unique Level 1 categories from action items
    function populateCategoryFilter() {
      const categoryFilter = document.getElementById('category-filter');
      const categoryFilterAll = document.getElementById('category-filter-all');
      if (!actionItems) return;
      
      // Get unique Level 1 categories from action items
      const categories = new Set();
      actionItems.forEach(item => {
        if (item.categoryPath) {
          // Only get the first level (e.g., "Imaging" from "Imaging/X-ray/Ankle")
          const pathParts = item.categoryPath.split('/');
          const level1Category = pathParts[0] ? pathParts[0].trim() : '';
          if (level1Category) {
            categories.add(level1Category);
          }
        }
      });
      
      // Update My Items category filter
      if (categoryFilter) {
        categoryFilter.innerHTML = '<option value="all">All Categories</option>';
        Array.from(categories).sort().forEach(category => {
          const option = document.createElement('option');
          option.value = category;
          option.textContent = category;
          categoryFilter.appendChild(option);
        });
      }
      
      // Update All Items category filter
      if (categoryFilterAll) {
        categoryFilterAll.innerHTML = '<option value="all">All Categories</option>';
        Array.from(categories).sort().forEach(category => {
          const option = document.createElement('option');
          option.value = category;
          option.textContent = category;
          categoryFilterAll.appendChild(option);
        });
      }
      
      console.log('Populated category filters with', categories.size, 'Level 1 categories:', Array.from(categories));
    }
    
    // Load action items
    function loadActionItems() {
      console.log('loadActionItems: Starting to load action items...');
      showSpinner('Loading action items...');
      
      try {
        console.log('loadActionItems: Calling getAndProcessClientActionItems...');
        google.script.run
          .withSuccessHandler(function(items) {
            console.log('loadActionItems: Successfully received items from server');
            console.log('ITEMS RECEIVED FROM SERVER:', items);
            console.log('ITEMS TYPE:', typeof items);
            console.log('ITEMS COUNT:', items ? items.length : 0);
            
            if (!items) {
              console.error('loadActionItems: Received null or undefined items from server');
              actionItems = [];
              renderActionItems();
              hideSpinner();
              return;
            }
            
            if (!Array.isArray(items)) {
              console.error('loadActionItems: Items is not an array:', items);
              items = [];
            }
            
            // Debug: Log each item's key fields
            if (items.length > 0) {
              console.log('loadActionItems: Processing', items.length, 'items');
              items.forEach((item, index) => {
                console.log(`Item ${index}:`, {
                  id: item.actionItemId,
                  title: item.title,
                  priority: item.priority,
                  status: item.status,
                  assignedTo: item.assignedTo,
                  categoryPath: item.categoryPath
                });
              });
            } else {
              console.log('loadActionItems: No items returned from server');
            }
            
            console.log('loadActionItems: Updating actionItems and rendering...');
            actionItems = items || [];
            
            try {
              console.log('loadActionItems: Populating filters...');
              populateAssignmentFilter();
              populateCreatedByFilter();
              populateCategoryFilter();
              console.log('loadActionItems: Rendering action items...');
              renderActionItems();
            } catch (renderError) {
              console.error('Error in render pipeline:', renderError);
              console.error('Stack:', renderError.stack);
              alert('Error rendering items: ' + renderError.message);
            }
            
            hideSpinner();
            console.log('loadActionItems: Completed successfully');
          })
          .withFailureHandler(function(error) {
            console.error('loadActionItems: Error loading action items:', error);
            console.error('Error stack:', error.stack);
            actionItems = [];
            try {
              renderActionItems();
            } catch (e) {
              console.error('Error in render after failure:', e);
            }
            hideSpinner();
            alert('Error loading action items. Please check console for details.');
          })
          .getAndProcessClientActionItems();
      } catch (e) {
        console.error('FATAL ERROR in loadActionItems:', e);
        console.error('Stack:', e.stack);
        actionItems = [];
        hideSpinner();
        alert('A critical error occurred while loading items. Please refresh the page.');
      }
    }
    
    // editActionItem function moved to line 891 - this duplicate removed

    async function selectCategoryPath(path) {
      if (!path || path.length === 0) return;

      // Ensure options are loaded before proceeding
      if (!actionItemOptions || !actionItemOptions.actionItems || !actionItemOptions.actionItems.categories) {
        console.log('Category data not loaded, loading now...');
        await new Promise(resolve => {
          loadActionItemOptions(() => {
            console.log('Category data loaded, proceeding with selectCategoryPath');
            resolve();
          });
        });
      }

      // Set the top-level category
      const categorySelect = document.getElementById('category-level-1');
      if (!categorySelect) {
        console.error('Category dropdown not found');
        return;
      }
      categorySelect.value = path[0];
      console.log(`Setting category level 1 to: ${path[0]}`);
      categorySelect.dispatchEvent(new Event('change', { bubbles: true }));

      // Sequentially set the value for each subsequent dropdown
      for (let i = 1; i < path.length; i++) {
        const level = i + 1;
        // Wait for the next dropdown to be created by the change event
        await new Promise(resolve => setTimeout(resolve, 100)); // Small delay to allow UI to update
        const nextSelect = document.querySelector(`select[data-level='${level}']`);
        if (nextSelect) {
          nextSelect.value = path[i];
          nextSelect.dispatchEvent(new Event('change'));
        } else {
          console.error(`Could not find dropdown for level ${level} with value ${path[i]}`);
          break;
        }
      }
    }

    function saveActionItem() {
      showSpinner('Saving action item...');
      
      const categorySelect = document.getElementById('category-level-1');
  const path = [categorySelect ? categorySelect.value : ''];
      const dynamicContainer = document.getElementById('dynamic-category-container');
      const dynamicSelects = dynamicContainer.querySelectorAll('select');
      dynamicSelects.forEach(select => {
        if (select.value) {
          path.push(select.value);
        }
      });

      const item = {
        actionItemId: document.getElementById('item-id').value,
        title: document.getElementById('item-title').value,
        description: document.getElementById('item-description').value,
        assignedTo: document.getElementById('item-assignee').value,
        dueDate: document.getElementById('item-due-date').value,
        priority: document.getElementById('item-priority').value,
        status: document.getElementById('item-status').value,
        mentionedUsers: document.getElementById('item-mentions').value,
        categoryPath: path.filter(p => p).join('/'),
      };
      
      google.script.run
        .withSuccessHandler(function(savedItem) {
          console.log('Item saved:', savedItem);
          closeModal();
          loadActionItems(); // This will refresh the entire list
          hideSpinner();
        })
        .withFailureHandler(function(error) {
          console.error('Error saving item:', error);
          hideSpinner();
          alert('Error saving item: ' + error);
        })
        .saveActionItem(item);
    }
    
    // Load action item options from the server
    function loadActionItemOptions(callback) {
      showSpinner('Loading options...');
      console.log('loadActionItemOptions: Starting to load action item options...');
      
      google.script.run
        .withSuccessHandler(function(options) {
          console.log('loadActionItemOptions: Received response from server');
          
          if (options && options.actionItems) {
            actionItemOptions = options;
            console.log('loadActionItemOptions: Successfully set actionItemOptions');
            
            // Directly populate the category dropdown
            const categorySelect = document.getElementById('category-level-1');
            if (categorySelect) {
              // Clear existing options except the first one
              while (categorySelect.options.length > 1) {
                categorySelect.remove(1);
              }
              
              const categories = options.actionItems.categories || {};
              console.log('Directly populating categories:', Object.keys(categories));
              
              // Add each category to the dropdown
              Object.entries(categories).forEach(([key, category]) => {
                const displayName = (category && typeof category === 'object' && category.title) || key;
                if (displayName) {
                  const option = new Option(displayName, key);
                  categorySelect.add(option);
                }
              });
              
              categorySelect.disabled = categorySelect.options.length <= 1;
              console.log(`Directly added ${categorySelect.options.length - 1} categories`);
            } else {
              console.error('Category select element not found');
            }
          } else {
            console.warn('loadActionItemOptions: Received incomplete options from server, using empty defaults');
            actionItemOptions = { 
              actionItems: { 
                categories: {}, 
                selectionTypes: {},
                optionsData: {}
              } 
            };
          }
          
          hideSpinner();
          
          // Execute callback if provided
          if (callback) {
            console.log('loadActionItemOptions: Executing callback');
            callback();
          }
        })
        .withFailureHandler(function(error) {
          console.error('loadActionItemOptions: Error loading action item options:', error);
          hideSpinner();
          alert('Error loading action item options: ' + error.message);
        })
        .getClientActionItemOptions();
    }
    
    // Legacy function to handle server errors
    function handleServerError(error) {
      console.error('Error loading options:', error);
      hideSpinner();
      alert('Error loading options: ' + error);
      
      // Call the callback with null if provided
      if (typeof callback === 'function') {
        callback(null);
      }
    }
    
    // Load templates
    function loadTemplates() {
      showSpinner('Loading templates...');
      
      google.script.run
        .withSuccessHandler(function(templates) {
          renderTemplates(templates);
          hideSpinner();
        })
        .withFailureHandler(function(error) {
          console.error('Error loading templates:', error);
          hideSpinner();
          alert('Error loading templates: ' + error);
        })
        .getActionItemTemplates();
    }
    
    // Render action items
    function renderActionItems() {
      console.log('RENDER: Starting renderActionItems');
      console.log('RENDER: currentUser =', currentUser);
      console.log('RENDER: currentTab =', currentTab);
      console.log('RENDER: actionItems count =', actionItems ? actionItems.length : 0);
      
      // Set current user each time we render to avoid race conditions
      currentUser = document.getElementById('user-email').textContent.trim();
      const myItemsContainer = document.getElementById('my-items-container');
      const allItemsContainer = document.getElementById('all-items-container');
      
      // Clear containers and check if actionItems is a valid array
      myItemsContainer.innerHTML = '';
      allItemsContainer.innerHTML = '';
      if (!actionItems || !Array.isArray(actionItems) || actionItems.length === 0) {
        console.log('RENDER: No action items to render');
        myItemsContainer.innerHTML = '<div class="empty-state">No action items found</div>';
        allItemsContainer.innerHTML = '<div class="empty-state">No action items found</div>';
        return;
      }
      
      let itemsToRender = [];
      
      if (currentTab === 'my-items') {
        let filteredItems = actionItems.filter(item => 
          item.assignedTo === currentUser || 
          item.createdBy === currentUser ||
          (item.mentionedUsers && item.mentionedUsers.includes(currentUser))
        );
        
        const statusFilter = document.getElementById('status-filter').value;
        const searchText = document.getElementById('search-input').value.toLowerCase();
        
        if (statusFilter !== 'all') {
          filteredItems = filteredItems.filter(item => item.status === statusFilter);
        }
        
        if (searchText) {
          filteredItems = filteredItems.filter(item => 
            (item.title && item.title.toLowerCase().includes(searchText)) ||
            (item.description && item.description.toLowerCase().includes(searchText))
          );
        }
        
        myItemsContainer.innerHTML = filteredItems.length > 0 
          ? filteredItems.map(item => renderActionItem(item)).join('')
          : '<div class="empty-state">No action items found for you.</div>';

      } else if (currentTab === 'all-items') {
        let filteredItems = actionItems;
        console.log('RENDER: All items - starting with', filteredItems.length, 'items');

        const assignmentFilter = document.getElementById('assignment-filter-all').value;
        const createdByFilter = document.getElementById('created-by-filter-all').value;
        const statusFilter = document.getElementById('status-filter-all').value;
        const priorityFilter = document.getElementById('priority-filter-all').value;
        const dueDateFilter = document.getElementById('due-date-filter-all').value;
        const categoryFilter = document.getElementById('category-filter-all').value;
        const searchText = document.getElementById('search-input-all').value.toLowerCase();
        console.log('RENDER: All items - filters:', { assignmentFilter, createdByFilter, statusFilter, priorityFilter, dueDateFilter, categoryFilter, searchText });
        
        // Assignment filter
        if (assignmentFilter !== 'all') {
          const beforeCount = filteredItems.length;
          filteredItems = filteredItems.filter(item => item.assignedTo === assignmentFilter);
          console.log('RENDER: All items - assignment filter reduced items from', beforeCount, 'to', filteredItems.length);
        }
        
        // Created By filter
        if (createdByFilter !== 'all') {
          const beforeCount = filteredItems.length;
          filteredItems = filteredItems.filter(item => item.createdBy === createdByFilter);
          console.log('RENDER: All items - created-by filter reduced items from', beforeCount, 'to', filteredItems.length);
        }
        
        // Status filter
        if (statusFilter !== 'all') {
          const beforeCount = filteredItems.length;
          filteredItems = filteredItems.filter(item => item.status === statusFilter);
          console.log('RENDER: All items - status filter reduced items from', beforeCount, 'to', filteredItems.length);
        }
        
        // Priority filter
        if (priorityFilter !== 'all') {
          const beforeCount = filteredItems.length;
          filteredItems = filteredItems.filter(item => item.priority === priorityFilter);
          console.log('RENDER: All items - priority filter reduced items from', beforeCount, 'to', filteredItems.length);
        }
        
        // Due Date filter
        if (dueDateFilter !== 'all') {
          const beforeCount = filteredItems.length;
          filteredItems = filteredItems.filter(item => matchesDueDateFilter(item.dueDate, dueDateFilter));
          console.log('RENDER: All items - due date filter reduced items from', beforeCount, 'to', filteredItems.length);
        }
        
        // Category filter (Level 1 only)
        if (categoryFilter !== 'all') {
          const beforeCount = filteredItems.length;
          filteredItems = filteredItems.filter(item => {
            const firstCategoryPart = item.categoryPath ? item.categoryPath.split('/')[0] : '';
            const level1Category = firstCategoryPart ? firstCategoryPart.trim() : '';
            return level1Category === categoryFilter;
          });
          console.log('RENDER: All items - category filter reduced items from', beforeCount, 'to', filteredItems.length);
        }
        
        // Search filter
        if (searchText) {
          const beforeCount = filteredItems.length;
          filteredItems = filteredItems.filter(item => 
            (item.title && item.title.toLowerCase().includes(searchText)) ||
            (item.description && item.description.toLowerCase().includes(searchText)) ||
            (item.assignedTo && item.assignedTo.toLowerCase().includes(searchText)) ||
            (item.categoryPath && item.categoryPath.toLowerCase().includes(searchText))
          );
          console.log('RENDER: All items - search filter reduced items from', beforeCount, 'to', filteredItems.length);
        }

        console.log('RENDER: All items - final filtered count:', filteredItems.length);
        allItemsContainer.innerHTML = filteredItems.length > 0 
          ? filteredItems.map(item => renderActionItem(item)).join('')
          : '<div class="empty-state">No action items found.</div>';
      }
      
      // Add click event listeners to action items
      document.querySelectorAll('.action-item').forEach(item => {
        // Handle clicks on the item content (not action buttons)
        item.addEventListener('click', function(event) {
          if (!event.target.closest('.item-actions') && !event.target.closest('.item-checkbox')) {
            const itemId = this.dataset.itemId;
            openCommentsModal(itemId); // Changed from openItemDetails to openCommentsModal
          }
        });
      });
      
      // Event delegation for action buttons
      ['my-items-container', 'all-items-container'].forEach(containerId => {
        const container = document.getElementById(containerId);
        if (container) {
          container.addEventListener('click', function(event) {
            const actionBtn = event.target.closest('.action-btn');
            if (!actionBtn) return;
            
            event.stopPropagation();
            const action = actionBtn.dataset.action;
            const itemElement = actionBtn.closest('.action-item');
            const itemId = itemElement?.dataset?.itemId;
            
            if (action && itemId) {
              handleActionItemClick(event, action, itemId);
            }
          });
        }
      });
    }
    
    // Handle action item button clicks
    function handleActionItemClick(event, action, itemId) {
      console.log('Action clicked:', action, 'for item:', itemId);
      
      switch (action) {
        case 'edit':
          editActionItem(itemId);
          break;
        case 'complete':
          completeActionItem(itemId);
          break;
        case 'self-assign':
          selfAssignItem(itemId);
          break;
        case 'comments':
          openCommentsModal(itemId);
          break;
        case 'delete':
          if (confirm('Are you sure you want to delete this action item?')) {
            deleteActionItem(itemId);
          }
          break;
        default:
          console.warn('Unknown action:', action);
      }
    }
    
    // Complete an action item
    function completeActionItem(itemId) {
      showSpinner('Completing action item...');
      
      google.script.run
        .withSuccessHandler(function(result) {
          console.log('Item completed:', result);
          loadActionItems(); // Refresh the list
          hideSpinner();
        })
        .withFailureHandler(function(error) {
          console.error('Error completing item:', error);
          hideSpinner();
          alert('Error completing item: ' + error);
        })
        .completeActionItem(itemId);
    }
    
    // Self-assign a single item
    function selfAssignItem(itemId) {
      const currentUser = getCurrentUserEmail();
      
      showSpinner('Self-assigning item...');
      
      google.script.run
        .withSuccessHandler(function(result) {
          console.log('Item self-assigned:', result);
          loadActionItems(); // Refresh the list
          hideSpinner();
        })
        .withFailureHandler(function(error) {
          console.error('Error self-assigning item:', error);
          hideSpinner();
          alert('Error self-assigning item: ' + error);
        })
        .assignActionItem(itemId, currentUser);
    }
    
    // Open comments modal and load comments with action item details
    function openCommentsModal(itemId) {
      currentActionItemId = itemId;
      const item = actionItems.find(i => i.actionItemId === itemId);
      if (!item) {
        alert('Action item not found');
        return;
      }
      
      // Show the modal
      const modal = document.getElementById('item-modal');
      if (modal) {
        modal.style.display = 'block';
        // Ensure modal is scrolled to top when opened
        modal.scrollTop = 0;
      }
      
      // Hide the form
      const form = document.getElementById('item-form');
      if (form) {
        form.style.display = 'none';
      }
      
      // Get or create the dynamic content container
      let dynamicContent = modal.querySelector('.modal-dynamic-content');
      if (!dynamicContent) {
        dynamicContent = document.createElement('div');
        dynamicContent.className = 'modal-dynamic-content';
        modal.querySelector('.modal-content').appendChild(dynamicContent);
      } else {
        dynamicContent.innerHTML = '';
      }
      
      // Create compact action item details section for comments modal
      const detailsHtml = `
        <div class="action-item-details compact-details">
          <div class="details-grid">
            <div class="detail-item">
              <span class="detail-label">Title:</span>
              <span class="detail-value">${item.title || 'Untitled'}</span>
            </div>
            ${item.description ? `
            <div class="detail-item">
              <span class="detail-label">Desc:</span>
              <span class="detail-value">${item.description}</span>
            </div>` : ''}
            <div class="detail-item">
              <span class="detail-label">Assigned:</span>
              <span class="detail-value">${item.assignedTo || 'Unassigned'}</span>
            </div>
            <div class="detail-item">
              <span class="detail-label">Due:</span>
              <span class="detail-value">${item.dueDate ? formatDate(item.dueDate) : 'Not set'}</span>
            </div>
            <div class="detail-item">
              <span class="detail-label">Priority:</span>
              <span class="detail-value">${item.priority || 'Not set'}</span>
            </div>
            <div class="detail-item">
              <span class="detail-label">Status:</span>
              <span class="detail-value">${item.status || 'Open'}</span>
            </div>
            <div class="detail-item">
              <span class="detail-label">Category:</span>
              <span class="detail-value">${item.categoryPath || 'No category'}</span>
            </div>
            ${item.mentionedUsers ? `
            <div class="detail-item">
              <span class="detail-label">Mentions:</span>
              <span class="detail-value">${Array.isArray(item.mentionedUsers) ? item.mentionedUsers.join(', ') : item.mentionedUsers}</span>
            </div>` : ''}
            <div class="detail-item">
              <span class="detail-label">Created:</span>
              <span class="detail-value">${item.createdBy || 'System'} • ${item.createdAt ? formatDate(item.createdAt) : 'Unknown'}</span>
            </div>
          </div>
        </div>
        <!-- Comments container will be populated by renderComments() -->
        <div id="comments-container" class="comments-list">
          <div class="loading-comments">Loading comments...</div>
        </div>`;
      
      // Append all content to dynamic content
      dynamicContent.innerHTML = detailsHtml;
      
      // Set up mentions after a short delay to ensure DOM is ready
      setTimeout(() => {
        console.log('Setting up mentions autocomplete for comments modal');
        setupMentionsAutocomplete('new-comment');
        
        // Add Enter key handler for the comment textarea
        const commentTextarea = document.getElementById('new-comment');
        if (commentTextarea) {
          commentTextarea.addEventListener('keydown', function(e) {
            // If Enter is pressed without Shift, submit the comment
            if (e.key === 'Enter' && !e.shiftKey) {
              e.preventDefault();
              addComment();
            }
            // Allow Shift+Enter for new lines
          });
        }
      }, 100);
      
      // Load comments for this item
      loadCommentsForItem(itemId);
      
      // Set focus to the comment textarea
      const commentTextarea = document.getElementById('new-comment');
      if (commentTextarea) {
        commentTextarea.focus();
      }
    }
    
    // Simple test function to verify backend connectivity
    function simpleTest() {
      console.log('Testing simple backend function...');
      
      google.script.run
        .withSuccessHandler(function(result) {
          console.log('SIMPLE TEST RESULT:', result);
          alert('Simple test result: ' + JSON.stringify(result, null, 2));
        })
        .withFailureHandler(function(error) {
          console.error('Simple test error:', error);
          alert('Simple test error: ' + error);
        })
        .simpleTest();
    }
    
    // Debug function to test comments sheet
    function debugCommentsSheet() {
      console.log('Testing comments sheet debug...');
      
      google.script.run
        .withSuccessHandler(function(result) {
          console.log('DEBUG SHEET RESULT:', result);
          alert('Debug result: ' + JSON.stringify(result, null, 2));
        })
        .withFailureHandler(function(error) {
          console.error('Debug sheet error:', error);
          alert('Debug error: ' + error);
        })
        .debugCommentsSheet();
    }
    
    // Load comments for a specific action item
    function loadCommentsForItem(itemId) {
      console.log('Loading comments for item:', itemId);
      showSpinner('Loading comments...');
      
      google.script.run
        .withSuccessHandler(function(comments) {
          console.log('Comments loaded:', comments);
          console.log('Comments type:', typeof comments);
          console.log('Comments length:', comments ? comments.length : 'null/undefined');
          renderComments(comments);
          hideSpinner();
        })
        .withFailureHandler(function(error) {
          console.error('Error loading comments:', error);
          hideSpinner();
          alert('Error loading comments: ' + error);
        })
        .getCommentsForActionItem(itemId);
    }
    
    // Format time ago string (e.g., '2 hours ago')
    function formatTimeAgo(date) {
      if (!(date instanceof Date)) {
        date = new Date(date);
      }
      
      const now = new Date();
      const seconds = Math.floor((now - date) / 1000);
      
      const intervals = {
        year: 31536000,
        month: 2592000,
        week: 604800,
        day: 86400,
        hour: 3600,
        minute: 60
      };
      
      for (const [unit, secondsInUnit] of Object.entries(intervals)) {
        const interval = Math.floor(seconds / secondsInUnit);
        if (interval >= 1) {
          return interval === 1 ? `1 ${unit} ago` : `${interval} ${unit}s ago`;
        }
      }
      
      return 'just now';
    }
    
    // Close the comments modal
    function closeCommentsModal() {
      const modal = document.getElementById('commentsModal');
      if (modal) {
        // Remove the modal from the DOM
        modal.remove();
        // Re-enable body scrolling
        document.body.style.overflow = 'auto';
      }
    }
    
    // Handle comment submission
    function handleCommentSubmit(e) {
      e.preventDefault();
      const commentText = document.getElementById('comment-input')?.value.trim();
      
      if (!commentText) {
        alert('Please enter a comment');
        return false;
      }
      
      if (!currentActionItemId) {
        alert('No action item selected');
        return false;
      }
      
      showSpinner('Posting comment...');
      
      const commentData = {
        content: commentText,
        author: getCurrentUserEmail(),
        timestamp: new Date().toISOString(),
        mentionedUsers: []
      };
      
      // Process mentions in the comment
      const mentionElements = document.querySelectorAll('.mention');
      mentionElements.forEach(mention => {
        const email = mention.getAttribute('data-email');
        if (email) {
          commentData.mentionedUsers.push(email);
        }
      });
      
      google.script.run
        .withSuccessHandler(function(savedComment) {
          console.log('Comment added:', savedComment);
          const commentInput = document.getElementById('comment-input');
          if (commentInput) commentInput.value = '';
          loadCommentsForItem(currentActionItemId);
          hideSpinner();
        })
        .withFailureHandler(function(error) {
          console.error('Error adding comment:', error);
          hideSpinner();
          alert('Error adding comment: ' + error);
        })
        .addCommentToActionItem(currentActionItemId, commentData);
      
      return false;
    }

    function renderComments(comments) {
      const container = document.getElementById('comments-container');
      if (!container) return;
      
      // Clear existing content
      container.innerHTML = '';
      
      // Add comment form at the top
      const form = document.createElement('form');
      form.id = 'comment-form';
      form.onsubmit = handleCommentSubmit;
      form.className = 'comment-form';
      form.style.width = '100%';
      form.innerHTML = `
        <div class="form-group mb-2">
          <textarea 
            id="comment-input" 
            class="form-control comment-input" 
            placeholder="Add a comment..." 
            rows="2"
            style="resize: none; border-radius: 18px; padding: 8px 12px; font-size: 14px;"
          ></textarea>
        </div>
        <div class="form-group d-flex justify-content-end align-items-center gap-2 mb-3">
          <button type="button" id="cancel-comment" class="btn btn-sm btn-outline-secondary">
            Cancel
          </button>
          <button type="submit" class="btn btn-sm btn-primary">
            Post Comment
          </button>
        </div>
      `;
      container.appendChild(form);
      
      // Add cancel button handler
      document.getElementById('cancel-comment')?.addEventListener('click', closeCommentsModal);
      
      // Setup mentions for the new comment input
      setupMentionsAutocomplete('comment-input');
      
      // Create a single comments container
      const commentsContainer = document.createElement('div');
      commentsContainer.className = 'comments-container-content';
      commentsContainer.style.padding = '0 8px';
      
      if (!comments || comments.length === 0) {
        const noComments = document.createElement('div');
        noComments.className = 'text-muted text-center py-3';
        noComments.textContent = 'No comments yet. Be the first to comment!';
        container.appendChild(noComments);
        return;
      }
      
      // Add comments header
      const commentsHeader = document.createElement('div');
      commentsHeader.className = 'comments-header';
      commentsHeader.innerHTML = `<h6 style="margin: 0; font-size: 15px; font-weight: 500; color: #202124;">${comments.length} ${comments.length === 1 ? 'Comment' : 'Comments'}</h6>`;
      container.appendChild(commentsHeader);
      
      // Create comments list container
      const commentsList = document.createElement('div');
      commentsList.className = 'comments-list';
      container.appendChild(commentsList);
      
      // Sort comments by timestamp in descending order (newest first)
      const sortedComments = [...comments].sort((a, b) => {
        const timeA = a.timestamp ? new Date(a.timestamp).getTime() : 0;
        const timeB = b.timestamp ? new Date(b.timestamp).getTime() : 0;
        return timeB - timeA; // Sort newest first
      });
      
      // Add comments to the list in reverse chronological order
      sortedComments.forEach(comment => {
        const { content, author, timestamp, mentionedUsers = [], lastEdited, commentId } = comment;
        const commentEl = document.createElement('div');
        const isCurrentUser = author === getCurrentUserEmail();
        commentEl.className = `comment ${isCurrentUser ? 'current-user' : ''}`;
        commentEl.setAttribute('data-comment-id', commentId);
        
        // Format the date
        const date = new Date(timestamp);
        const formattedDate = date.toLocaleString('en-US', {
          month: 'short',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
        
        // Calculate time ago
        const timeAgo = formatTimeAgo(date);
        
        // Get user's display name (first and last name if available, otherwise username)
        const user = availableUsers.find(u => u.email === author);
        const displayName = user ? 
          `${user.firstName || ''} ${user.lastName || ''}`.trim() : 
          author.split('@')[0];
        
        // Process mentions in the comment content
        let processedContent = content;
        const mentions = Array.isArray(mentionedUsers) ? mentionedUsers : [];
        mentions.forEach(mention => {
          if (mention) {
            const mentionUser = availableUsers.find(u => u.email === mention);
            const mentionName = mentionUser?.lastName || mentionUser?.firstName || mention.split('@')[0];
            const mentionRegex = new RegExp(`@${mention}`.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
            processedContent = processedContent.replace(
              mentionRegex, 
              `<span class="mention" data-email="${mention}">@${mentionName}</span>`
            );
          }
        });
        
        // Create comment HTML with bubble
        const commentHTML = `
          <div class="comment-bubble">
            <div class="comment-header">
              <span class="comment-author">${displayName}</span>
              <span class="comment-time" title="${formattedDate}">${timeAgo}</span>
              ${lastEdited ? '<span class="comment-edited">(edited)</span>' : ''}
            </div>
            <div class="comment-content">${processedContent}</div>
          </div>
          <div class="comment-actions">
            <span class="comment-action" onclick="handleCommentAction('like', '${comment.commentId}')">Like</span>
            <span class="comment-action" onclick="handleCommentAction('reply', '${comment.commentId}')">Reply</span>
            ${isCurrentUser ? `
              <span class="comment-action" onclick="handleCommentAction('edit', '${comment.commentId}')">Edit</span>
              <span class="comment-action" onclick="handleCommentAction('delete', '${comment.commentId}')">Delete</span>
            ` : ''}
          </div>
        `;
        
        commentEl.innerHTML = commentHTML;
        
        // Append to maintain reverse chronological order
        commentsList.appendChild(commentEl);
      });
    }
    
    // Handle comment actions (like, reply, edit, delete)
    function handleCommentAction(action, commentId, event) {
      if (event) event.stopPropagation();
      
      const comment = actionItems
        .flatMap(item => item.comments || [])
        .find(c => c.commentId === commentId);
      
      if (!comment) return;
      
      const commentEl = document.querySelector(`[data-comment-id="${commentId}"]`);
      const isCurrentUser = comment.author === getCurrentUserEmail();
      
      switch (action) {
        case 'like':
          // Toggle like
          const likes = comment.likes || [];
          const userEmail = getCurrentUserEmail();
          const likeIndex = likes.indexOf(userEmail);
          
          if (likeIndex === -1) {
            comment.likes = [...likes, userEmail];
          } else {
            comment.likes = likes.filter((_, i) => i !== likeIndex);
          }
          
          // Update the UI
          const likeBtn = document.querySelector(`[onclick*="handleCommentAction('like', '${commentId}')"]`);
          if (likeBtn) {
            likeBtn.textContent = comment.likes.includes(userEmail) 
              ? `Liked (${comment.likes.length})` 
              : `Like (${comment.likes.length || ''})`;
          }
          
          // Save the updated comment
          saveComment(comment);
          break;
          
        case 'reply':
          // Focus the comment input and add @mention
          const commentInput = document.getElementById('comment-input');
          if (commentInput) {
            const user = availableUsers.find(u => u.email === comment.author);
            const displayName = user?.lastName || user?.firstName || comment.author.split('@')[0];
            commentInput.value = `@${displayName} `;
            commentInput.focus();
          }
          break;
          
        case 'edit':
          if (!isCurrentUser) return;
          
          // Create edit form
          const editForm = document.createElement('div');
          editForm.className = 'comment-edit-form';
          editForm.innerHTML = `
            <textarea class="comment-edit-input">${comment.content}</textarea>
            <div class="comment-edit-actions">
              <button class="btn btn-sm btn-outline-secondary" onclick="cancelEditComment('${commentId}')">Cancel</button>
              <button class="btn btn-sm btn-primary" onclick="saveEditedComment('${commentId}', this)">Save</button>
            </div>
          `;
          
          // Replace comment content with edit form
          const contentEl = commentEl?.querySelector('.comment-content');
          if (contentEl) {
            contentEl.style.display = 'none';
            contentEl.after(editForm);
            
            // Focus the textarea
            const textarea = editForm.querySelector('textarea');
            if (textarea) {
              textarea.focus();
              textarea.setSelectionRange(textarea.value.length, textarea.value.length);
            }
          }
          break;
          
        case 'delete':
          if (!isCurrentUser) return;
          
          if (confirm('Are you sure you want to delete this comment?')) {
            // Find and remove the comment from the action item
            actionItems.forEach(item => {
              if (item.comments) {
                const index = item.comments.findIndex(c => c.commentId === commentId);
                if (index !== -1) {
                  item.comments.splice(index, 1);
                  // Update the UI
                  commentEl?.remove();
                  // Save changes
                  saveActionItem(item);
                }
              }
            });
          }
          break;
      }
    }
    
    // Save an edited comment
    function saveEditedComment(commentId, button) {
      const comment = actionItems
        .flatMap(item => item.comments || [])
        .find(c => c.commentId === commentId);
      
      if (!comment) return;
      
      const commentEl = document.querySelector(`[data-comment-id="${commentId}"]`);
      const editForm = commentEl?.querySelector('.comment-edit-form');
      const textarea = editForm?.querySelector('textarea');
      const contentEl = commentEl?.querySelector('.comment-content');
      
      if (!textarea || !contentEl) return;
      
      const newContent = textarea.value.trim();
      if (!newContent) return;
      
      // Update comment content
      comment.content = newContent;
      comment.lastEdited = new Date().toISOString();
      
      // Update the UI
      contentEl.innerHTML = comment.content;
      contentEl.style.display = '';
      editForm.remove();
      
      // Show edited indicator
      const editedEl = commentEl.querySelector('.comment-edited') || document.createElement('span');
      if (!editedEl.classList.contains('comment-edited')) {
        editedEl.className = 'comment-edited';
        editedEl.textContent = ' (edited)';
        const timeEl = commentEl.querySelector('.comment-time');
        timeEl.after(editedEl);
      }
      
      // Save the updated comment
      saveComment(comment);
      
      // Re-enable the save button if it was disabled
      if (button) button.disabled = false;
    }
    
    // Cancel editing a comment
    function cancelEditComment(commentId) {
      const commentEl = document.querySelector(`[data-comment-id="${commentId}"]`);
      const editForm = commentEl?.querySelector('.comment-edit-form');
      const contentEl = commentEl?.querySelector('.comment-content');
      
      if (editForm && contentEl) {
        contentEl.style.display = '';
        editForm.remove();
      }
    }
    
    // Save a comment to the backend
    function saveComment(comment) {
      // Find the parent action item
      const actionItem = actionItems.find(item => 
        item.comments?.some(c => c.commentId === comment.commentId)
      );
      
      if (!actionItem) return;
      
      // Update the comment in the action item
      const commentIndex = actionItem.comments.findIndex(c => c.commentId === comment.commentId);
      if (commentIndex !== -1) {
        actionItem.comments[commentIndex] = comment;
      }
      
      // Save the updated action item
      saveActionItem(actionItem);
    }
    
    // Handle Enter key in comment textarea
    function handleCommentKeyDown(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        
        // Show loading state
        const button = document.getElementById('post-comment-btn');
        const originalText = button.textContent;
        button.disabled = true;
        button.innerHTML = '<i class="material-icons spin">refresh</i> Posting...';
        
        // Small delay to show loading state
        setTimeout(() => {
          addComment();
          button.disabled = false;
          button.textContent = originalText;
        }, 100);
      }
    }
    
    // Process @mentions in text and make them clickable
    function processMentionsInText(text) {
      if (!text) return '';
      
      // Replace @email mentions with styled spans
      return text.replace(/@([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/g, 
        '<span class="mention">@$1</span>');
    }
    
    // Add a new comment
    function addComment() {
      const commentText = document.getElementById('new-comment').value.trim();
      
      if (!commentText) {
        alert('Please enter a comment');
        return;
      }
      
      if (!currentActionItemId) {
        alert('No action item selected');
        return;
      }
      
      showSpinner('Adding comment...');
      
      const commentData = {
        content: commentText,
        author: getCurrentUserEmail()
      };
      
      google.script.run
        .withSuccessHandler(function(savedComment) {
          console.log('Comment added:', savedComment);
          document.getElementById('new-comment').value = ''; // Clear the textarea
          loadCommentsForItem(currentActionItemId); // Reload comments
          hideSpinner();
        })
        .withFailureHandler(function(error) {
          console.error('Error adding comment:', error);
          hideSpinner();
          alert('Error adding comment: ' + error);
        })
        .addCommentToActionItem(currentActionItemId, commentData);
    }
    
    // Load activity feed with filters
    function loadActivityFeed() {
      showSpinner('Loading activity feed...');
      
      const filters = {
        type: document.getElementById('feed-filter-type').value,
        timeframe: document.getElementById('feed-filter-timeframe').value,
        search: document.getElementById('feed-search').value.trim()
      };
      
      console.log('Loading activity feed with filters:', filters);
      
      google.script.run
        .withSuccessHandler(function(activities) {
          console.log('Activity feed loaded:', activities);
          renderActivityFeed(activities);
          hideSpinner();
        })
        .withFailureHandler(function(error) {
          console.error('Error loading activity feed:', error);
          hideSpinner();
          alert('Error loading activity feed: ' + error);
        })
        .getActivityFeed(filters);
    }
    
    // Render activity feed items
    function renderActivityFeed(activities) {
      const container = document.getElementById('activity-feed-container');
      
      if (!activities || activities.length === 0) {
        container.innerHTML = '<div class="empty-state">No recent activity found. Try adjusting your filters or check back later!</div>';
        return;
      }
      
      const activitiesHtml = activities.map(activity => {
        const timestamp = new Date(activity.timestamp).toLocaleString();
        const timeAgo = getTimeAgo(new Date(activity.timestamp));
        const content = activity.content || '';
        const author = activity.author || 'Unknown';
        const actionItemTitle = activity.actionItemTitle || 'Unknown Item';
        
        // Process mentions in the content
        const processedContent = processMentionsInText(content);
        
        let activityIcon = '';
        let activityTypeClass = '';
        let activityDescription = '';
        
        switch (activity.type) {
          case 'comment':
            activityIcon = '💬';
            activityTypeClass = 'activity-comment';
            activityDescription = `commented on`;
            break;
          case 'mention':
            activityIcon = '👤';
            activityTypeClass = 'activity-mention';
            activityDescription = `mentioned ${activity.mentionedUsers ? activity.mentionedUsers.join(', ') : 'someone'} in`;
            break;
          case 'status-change':
            activityIcon = '🔄';
            activityTypeClass = 'activity-status';
            activityDescription = `changed status of`;
            break;
          default:
            activityIcon = '📝';
            activityTypeClass = 'activity-other';
            activityDescription = `updated`;
        }
        
        return `
          <div class="activity-item ${activityTypeClass}">
            <div class="activity-icon">${activityIcon}</div>
            <div class="activity-content">
              <div class="activity-header">
                <span class="activity-author">${author}</span>
                <span class="activity-description">${activityDescription}</span>
                <span class="activity-item-title" onclick="openCommentsModal('${activity.actionItemId}')">${actionItemTitle}</span>
                <span class="activity-timestamp" title="${timestamp}">${timeAgo}</span>
              </div>
              ${processedContent ? `<div class="activity-text">${processedContent}</div>` : ''}
            </div>
          </div>
        `;
      }).join('');
      
      container.innerHTML = `<div class="activity-feed">${activitiesHtml}</div>`;
    }
    
    // Get human-readable time ago string
    function getTimeAgo(date) {
      const now = new Date();
      const diffMs = now - date;
      const diffMins = Math.floor(diffMs / (1000 * 60));
      const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
      const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
      
      if (diffMins < 1) {
        return 'just now';
      } else if (diffMins < 60) {
        return `${diffMins}m ago`;
      } else if (diffHours < 24) {
        return `${diffHours}h ago`;
      } else if (diffDays < 7) {
        return `${diffDays}d ago`;
      } else {
        return date.toLocaleDateString();
      }
    }
    
    // View action item from activity feed
    function viewActionItem(itemId) {
      // Switch to appropriate tab and highlight the item
      const item = actionItems.find(i => i.actionItemId === itemId);
      if (!item) {
        alert('Action item not found');
        return;
      }
      
      // Determine which tab the item should be in
      const currentUser = getCurrentUserEmail();
      const isMyItem = item.assignedTo === currentUser || 
                      item.createdBy === currentUser ||
                      (item.mentionedUsers && item.mentionedUsers.includes(currentUser));
      
      // Switch to the appropriate tab
      const targetTab = isMyItem ? 'my-items' : 'all-items';
      switchTab(targetTab);
      
      // Highlight the item (add a visual indicator)
      setTimeout(() => {
        const itemElement = document.querySelector(`[data-item-id="${itemId}"]`);
        if (itemElement) {
          itemElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
          itemElement.classList.add('highlighted-item');
          setTimeout(() => {
            itemElement.classList.remove('highlighted-item');
          }, 3000);
        }
      }, 500);
    }
    
    // View action item details in a read-only modal

    
    // Clear activity feed filters
    function clearActivityFeedFilters() {
      document.getElementById('feed-filter-type').value = 'all';
      document.getElementById('feed-filter-timeframe').value = 'week';
      document.getElementById('feed-search').value = '';
      loadActivityFeed();
    }
    
    // Debounce utility function
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }
    
    // Delete action item
    function deleteActionItem(itemId) {
      showSpinner('Deleting action item...');
      
      google.script.run
        .withSuccessHandler(function(result) {
          console.log('Item deleted:', result);
          loadActionItems(); // Refresh the list
          hideSpinner();
        })
        .withFailureHandler(function(error) {
          console.error('Error deleting item:', error);
          hideSpinner();
          alert('Error deleting item: ' + error);
        })
        .deleteActionItem(itemId);
    }
    
    // Render a single action item
    function renderActionItem(item) {
      const statusClass = getStatusClass(item.status);
      const priorityClass = getPriorityClass(item.priority);
      const isOverdue = item.dueDate && new Date(item.dueDate) < new Date();
      const overdueClass = isOverdue ? 'overdue' : '';
      
      return `
        <div class="action-item ${overdueClass}" data-item-id="${item.actionItemId}">
          <div class="item-checkbox">
            <input type="checkbox" id="item-${item.actionItemId}" data-item-id="${item.actionItemId}">
          </div>
          <div class="item-content">
            <div class="item-header">
              <h3 class="item-title">${item.title}</h3>
              <div class="item-badges">
                <span class="status-badge ${statusClass}">${item.status}</span>
                ${item.priority ? `<span class="priority-badge ${priorityClass}">${item.priority}</span>` : ''}
                ${isOverdue ? '<span class="overdue-badge">OVERDUE</span>' : ''}
              </div>
            </div>
            <p class="item-description">${item.description || ''}</p>
            <div class="item-meta">
              <div class="meta-row">
                <span class="item-category">${item.categoryPath || 'No category'}</span>
                ${item.dueDate ? `<span class="item-due-date">Due: ${formatDate(item.dueDate)}</span>` : ''}
              </div>
              <div class="meta-row">
                <span class="item-assignee">${item.assignedTo ? `Assigned to: ${item.assignedTo}` : 'Unassigned'}</span>
                ${item.mentionedUsers ? `<span class="item-mentions">Mentions: ${item.mentionedUsers}</span>` : ''}
              </div>
            </div>
          </div>
          <div class="item-actions">
            ${item.createdBy === getCurrentUserEmail() ? `
              <button class="action-btn primary" data-action="edit">Edit</button>
              <button class="action-btn danger" data-action="delete">Delete</button>
            ` : ''}
            ${item.status !== 'Completed' ? `<button class="action-btn success" data-action="complete">Complete</button>` : ''}
            ${!item.assignedTo || item.assignedTo === '' ? `<button class="action-btn secondary" data-action="self-assign">Self-Assign</button>` : ''}
          </div>
        </div>
      `;
    }

    // Get status class
    function getStatusClass(status) {
      switch (status) {
        case 'Open': return 'status-open';
        case 'In Progress': return 'status-in-progress';
        case 'Updating': return 'status-in-progress';
        case 'Pending Approval': return 'status-pending';
        case 'Completed': return 'status-completed';
        default: return '';
      }
    }
    
    // Get priority class
    function getPriorityClass(priority) {
      switch (priority) {
        case 'High': return 'priority-high';
        case 'Medium': return 'priority-medium';
        case 'Low': return 'priority-low';
        default: return '';
      }
    }

    // Format date
    function formatDate(date) {
      if (!date) return '';
      const d = new Date(date);
      return d.toLocaleDateString();
    }

    // Format date for input fields
    function formatDateForInput(date) {
      const d = new Date(date);
      return d.toISOString().split('T')[0];
    }

    // View server logs
    function viewServerLogs() {
      console.log('Fetching server logs...');
      showSpinner('Fetching server logs...');

      google.script.run
        .withSuccessHandler(function(logs) {
          hideSpinner();
          console.log('Server logs received:', logs);

          // Create modal for logs
          const modal = document.createElement('div');
          modal.style.position = 'fixed';
          modal.style.left = '0';
          modal.style.top = '0';
          modal.style.width = '100%';
          modal.style.height = '100%';
          modal.style.backgroundColor = 'rgba(0,0,0,0.7)';
          modal.style.zIndex = '10000';
          modal.style.display = 'flex';
          modal.style.justifyContent = 'center';
          modal.style.alignItems = 'center';

          const content = document.createElement('div');
          content.style.backgroundColor = 'white';
          content.style.padding = '20px';
          content.style.borderRadius = '5px';
          content.style.width = '80%';
          content.style.height = '80%';
          content.style.overflow = 'auto';

          const closeBtn = document.createElement('button');
          closeBtn.textContent = 'Close';
          closeBtn.style.marginBottom = '10px';
          closeBtn.addEventListener('click', function() {
            document.body.removeChild(modal);
          });

          const pre = document.createElement('pre');
          pre.style.whiteSpace = 'pre-wrap';
          pre.style.wordBreak = 'break-word';
          pre.textContent = logs;

          content.appendChild(closeBtn);
          content.appendChild(pre);
          modal.appendChild(content);
          document.body.appendChild(modal);
        })
        .withFailureHandler(handleServerError)
        .getClientActionItemOptions();
    }

    function openNewItemModal() {
      const modal = document.getElementById('item-modal');
      const form = document.getElementById('item-form');
      const modalTitle = document.getElementById('modal-title');

      // 1. Reset the form completely for a new item
      if (form) form.reset();
      document.getElementById('item-id').value = '';
      document.getElementById('dynamic-category-container').innerHTML = ''; // Clear previous dynamic dropdowns

      // 2. Reset all fields to be editable by default
      const fields = ['title', 'description', 'status', 'priority', 'assignee', 'tags', 'mentions', 'diagnosisCode', 'diagnosisName'];
      fields.forEach(field => {
        const element = form.querySelector(`#item-${field.replace(/([A-Z])/g, '-$1').toLowerCase()}`);
        if (element) {
          element.readOnly = false;
          element.classList.remove('readonly');
        }
      });

      // 3. Set modal title for a new item
      if (modalTitle) modalTitle.textContent = 'New Action Item';

      // 4. Load/reload options and populate the first dropdown as a callback
      console.log('Loading options and populating categories...');
      loadActionItemOptions(populateTopLevelCategories);

      // 5. Show the modal
      if (modal) modal.style.display = 'block';
    }

    // Open new template modal
    function openNewTemplateModal() {
      const modal = document.getElementById('item-modal');
      const form = document.getElementById('item-form');
      const modalTitle = document.getElementById('modal-title');

      // Reset form
      if (form) form.reset();

      // Reset item ID
      const itemIdField = document.getElementById('item-id');
      if (itemIdField) itemIdField.value = '';

      // Set modal title
      if (modalTitle) modalTitle.textContent = 'New Template';

      // Set template flag
      const isTemplateField = document.getElementById('is-template');
      if (isTemplateField) isTemplateField.value = 'true';

      // Load options if not already loaded
      if (!actionItemOptions) {
        loadActionItemOptions(function() {
          updateCategoryOptions();
        });
      } else {
        updateCategoryOptions();
      }

      // Show modal
      if (modal) modal.style.display = 'block';
      else if (typeof $ !== 'undefined' && $('#new-item-modal').length) {
        $('#new-item-modal').modal('show');
      }
    }

    // Open item details
    function openItemDetails(itemId) {
      const modal = document.getElementById('item-modal');
      const modalTitle = document.getElementById('modal-title');

      // Find the item
      const item = actionItems.find(item => item.actionItemId === itemId);

      if (!item) {
        alert('Item not found');
        return;
      }

      // Set modal title
      modalTitle.textContent = 'Edit Action Item';

      // Fill form with item data
      document.getElementById('item-id').value = item.actionItemId;

      document.getElementById('item-status').value = item.status;
      document.getElementById('item-title').value = item.title;
      document.getElementById('item-description').value = item.description || '';
      document.getElementById('item-assignee').value = item.assignedTo || '';
      document.getElementById('item-due-date').value = item.dueDate ? formatDateForInput(item.dueDate) : '';
      document.getElementById('item-mentions').value = Array.isArray(item.mentionedUsers) ? item.mentionedUsers.join(', ') : (item.mentionedUsers || '');
      document.getElementById('item-tags').value = item.tags ? item.tags.join(', ') : '';

      // Initialize category dropdowns
      populateTopLevelCategories();

      // If item has category path, set the appropriate selections
      if (item.categoryPath) {
        const pathParts = item.categoryPath.split('/');

        // Wait for options to load
        setTimeout(() => {
          // Set category if available
          if (pathParts.length > 0 && pathParts[0]) {
            const categorySelect = document.getElementById('category-level-1');
            setSelectOption(categorySelect, pathParts[0]);
            updateSubcategoryOptions();

            // Set subcategory if available
            if (pathParts.length > 1 && pathParts[1]) {
              setTimeout(() => {
                const subcategorySelect = document.getElementById('item-subcategory');
                setSelectOption(subcategorySelect, pathParts[1]);
                updateOptionsList();

                // Set option if available
                if (pathParts.length > 2 && pathParts[2]) {
                  setTimeout(() => {
                    const optionSelect = document.getElementById('item-option');
                    setSelectOption(optionSelect, pathParts[2]);
                  }, 100);
                }
              }, 100);
            }
          }
        }, 100);
      }

      // Show modal
      modal.style.display = 'block';

      // Load comments
      loadComments(itemId);

      // Load history
      loadHistory(itemId);
    }

    // Helper function to set select option by value
    function setSelectOption(selectElement, value) {
      for (let i = 0; i < selectElement.options.length; i++) {
        if (selectElement.options[i].value === value) {
          selectElement.selectedIndex = i;
          return true;
        }
      }
      return false;
    }

    // Load comments
    function loadComments(itemId) {
      const commentsContainer = document.getElementById('comments-container');
      if (!commentsContainer) {
        console.warn('Comments container not found');
        return;
      }
      commentsContainer.innerHTML = '<div class="loading">Loading comments...</div>';

      google.script.run
        .withSuccessHandler(function(comments) {
          if (comments.length === 0) {
            commentsContainer.innerHTML = '<div class="empty-state">No comments yet</div>';
            return;
          }

          commentsContainer.innerHTML = comments.map(comment => `
            <div class="comment">
              <div class="comment-header">
                <span class="comment-author">${comment.author}</span>
                <span class="comment-date">${formatDate(comment.timestamp)}</span>
              </div>
              <div class="comment-content">${comment.content}</div>
            </div>
          `).join('');
        })
        .withFailureHandler(function(error) {
          console.error('Error loading comments:', error);
          commentsContainer.innerHTML = '<div class="error">Error loading comments</div>';
        })
        .getCommentsForActionItem(itemId);
    }

    // Load history
    function loadHistory(itemId) {
      const historyContainer = document.getElementById('history-container');
      if (!historyContainer) {
        console.warn('History container not found');
        return;
      }
      historyContainer.innerHTML = '<div class="loading">Loading history...</div>';

      google.script.run
        .withSuccessHandler(function(history) {
          if (history.length === 0) {
            historyContainer.innerHTML = '<div class="empty-state">No history yet</div>';
            return;
          }

          historyContainer.innerHTML = history.map(event => `
            <div class="history-item">
              <div class="history-header">
                <span class="history-date">${formatDate(event.changedAt)}</span>
                <span class="history-user">${event.changedBy}</span>
              </div>
              <div class="history-content">
                Changed ${event.fieldChanged} from "${event.oldValue}" to "${event.newValue}"
              </div>
            </div>
          `).join('');
        })
        .withFailureHandler(function(error) {
          console.error('Error loading history:', error);
          historyContainer.innerHTML = '<div class="error">Error loading history</div>';
        })
        .getActionItemHistory(itemId);
    }

    // Helper function to handle category selection for an item
    function handleCategorySelection(item) {
      if (!item.categoryPath) return;
      
      console.log('Attempting to select category path:', item.categoryPath);
      const pathParts = item.categoryPath.split('/');
      
      // First, ensure the first category is selected
      const categorySelect = document.getElementById('category-level-1');
      if (categorySelect && pathParts[0]) {
        // Set the value directly first
        categorySelect.value = pathParts[0];
        // Trigger change event to load subcategories
        const event = new Event('change', { bubbles: true });
        categorySelect.dispatchEvent(event);
      }
      
      // Then handle the full path after a short delay to allow subcategories to load
      setTimeout(() => {
        try {
          selectCategoryPath(pathParts);
        } catch (error) {
          console.warn('Failed to select category path, but form is still populated:', error);
        }
      }, 200);
    }

    // Edit action item
    function editActionItem(actionItemId) {
      const item = actionItems.find(i => i.actionItemId === actionItemId);
      if (!item) {
        console.error('Action item not found for editing:', actionItemId);
        return;
      }

      console.log('Editing action item:', item);

      // Get modal and form elements
      const modal = document.getElementById('item-modal');
      const form = document.getElementById('item-form');
      const modalTitle = document.getElementById('modal-title');

      // Set modal title for editing
      if (modalTitle) modalTitle.textContent = 'Edit Action Item';
      
      // Reset form but preserve the ID
      if (form) form.reset();
      
      // Clear previous dynamic dropdowns
      const categoryContainer = document.getElementById('dynamic-category-container');
      if (categoryContainer) categoryContainer.innerHTML = '';
      
      // Load options first, then populate the form
      loadActionItemOptions(() => {
        // Set the item ID first
        document.getElementById('item-id').value = item.actionItemId || '';
      document.getElementById('item-title').value = item.title || '';
      document.getElementById('item-description').value = item.description || '';
      document.getElementById('item-assignee').value = item.assignedTo || '';
      document.getElementById('item-due-date').value = item.dueDate ? item.dueDate.split('T')[0] : '';
      document.getElementById('item-priority').value = item.priority || 'Medium';
        document.getElementById('item-status').value = item.status || 'Open';
    
        // Populate other fields if they exist
        const tagsField = document.getElementById('item-tags');
        if (tagsField && item.tags) {
          tagsField.value = Array.isArray(item.tags) ? item.tags.join(', ') : item.tags;
        }
    
        const mentionsField = document.getElementById('item-mentions');
        if (mentionsField && item.mentionedUsers) {
          mentionsField.value = Array.isArray(item.mentionedUsers) ? item.mentionedUsers.join(', ') : item.mentionedUsers;
        }

        // Show the modal first
        if (modal) modal.style.display = 'block';
        
        // Ensure the category dropdown is populated before trying to select a value
        const categorySelect = document.getElementById('category-level-1');
        if (categorySelect && categorySelect.options.length <= 1) {
          // If the category dropdown isn't populated yet, wait for it
          const checkCategorySelect = setInterval(() => {
            if (categorySelect.options.length > 1) {
              clearInterval(checkCategorySelect);
              handleCategorySelection(item);
            }
          }, 50);
        } else {
          // If the dropdown is already populated, proceed with selection
          handleCategorySelection(item);
        }
      });
    }

    async function selectCategoryPath(path) {
      if (!path || path.length === 0) return;

      // Ensure options are loaded before proceeding
      if (!actionItemOptions || !actionItemOptions.actionItems || !actionItemOptions.actionItems.categories) {
        console.log('Category data not loaded, loading now...');
        await new Promise(resolve => {
          loadActionItemOptions(() => {
            console.log('Category data loaded, proceeding with selectCategoryPath');
            resolve();
          });
        });
      }

      // Set the top-level category
      const categorySelect = document.getElementById('category-level-1');
      if (!categorySelect) {
        console.error('Category dropdown not found');
        return;
      }
      categorySelect.value = path[0];
      console.log(`Setting category level 1 to: ${path[0]}`);
      categorySelect.dispatchEvent(new Event('change', { bubbles: true }));

      // Create all necessary dropdowns for the path
      let currentCategories = actionItemOptions.actionItems.categories;
      console.log('Available categories:', Object.keys(currentCategories || {}));
      
      for (let i = 1; i < path.length; i++) {
        const level = i + 1;
        const pathValue = path[i];
        const previousPathValue = path[i-1];
        
        console.log(`Looking for category '${previousPathValue}' in:`, Object.keys(currentCategories || {}));
        
        // Navigate to the subcategories for this level
        if (currentCategories && currentCategories[previousPathValue]) {
          currentCategories = currentCategories[previousPathValue].subcategories;
          console.log(`Found subcategories for '${previousPathValue}':`, Object.keys(currentCategories || {}));
          
          if (currentCategories && Object.keys(currentCategories).length > 0) {
            // Create the dropdown for this level if it doesn't exist
            let nextSelect = document.querySelector(`select[data-level='${level}']`);
            if (!nextSelect) {
              console.log(`Creating dropdown for level ${level}`);
              createCategoryDropdown(level, currentCategories);
              nextSelect = document.querySelector(`select[data-level='${level}']`);
            }
            
            // Set the value
            if (nextSelect) {
              nextSelect.value = pathValue;
              console.log(`Set level ${level} to: ${pathValue}`);
            } else {
              console.error(`Failed to create dropdown for level ${level}`);
              break;
            }
          } else {
            console.log(`No subcategories available for level ${level}`);
            break;
          }
        } else {
          console.warn(`Category '${previousPathValue}' not found in current data structure. Available categories:`, Object.keys(currentCategories || {}));
          // Don't break - just log the warning and continue
          // This allows the form to still populate even if the category path is outdated
          break;
        }
      }
    }

    // Save action item
    function saveActionItem() {
      showSpinner('Saving action item...');

      const pathParts = [];
      let level = 1;
      let dropdown;
      while (dropdown = document.querySelector(`select[data-level='${level}']`)) {
        if (dropdown.value) {
          pathParts.push(dropdown.value);
        } else {
          // Stop if a dropdown is not selected, as the path is incomplete
          break;
        }
        level++;
      }

      const item = {
        actionItemId: document.getElementById('item-id').value,
        title: document.getElementById('item-title').value,
        description: document.getElementById('item-description').value,
        assignedTo: document.getElementById('item-assignee').value,
        dueDate: document.getElementById('item-due-date').value,
        priority: document.getElementById('item-priority').value,
        status: document.getElementById('item-status').value,
        mentionedUsers: document.getElementById('item-mentions').value,
        categoryPath: pathParts.join('/'),
      };

      google.script.run
        .withSuccessHandler(function(savedItem) {
          console.log('Item saved:', savedItem);
          closeModal();
          loadActionItems();
          hideSpinner();
        })
        .withFailureHandler(function(error) {
          console.error('Error saving item:', error);
          hideSpinner();
          alert('Error saving item: ' + error);
        })
        .saveActionItem(item);
    }

    // User autocomplete for mentions
    let availableUsers = [];
    let mentionDropdown = null;
    
    // Load users for admin functionality
    function loadUsers() {
      google.script.run
        .withSuccessHandler(function(users) {
          allUsers = users || [];
          console.log('Loaded users:', allUsers.length);
          populateUserDropdowns();
          // Use the existing renderUsersTable function
          if (typeof renderUsersTable === 'function') {
            renderUsersTable(users);
          }
        })
        .withFailureHandler(function(error) {
          console.error('Error loading users:', error);
          showError('Failed to load users: ' + error);
        })
        .getUsers();
    }
    
    // Load notification groups for admin functionality
    function loadNotificationGroups() {
      google.script.run
        .withSuccessHandler(function(groups) {
          allGroups = groups || [];
          console.log('Loaded notification groups:', allGroups.length);
          // Use the existing renderGroupsTable function
          if (typeof renderGroupsTable === 'function') {
            renderGroupsTable(groups);
          }
        })
        .withFailureHandler(function(error) {
          console.error('Error loading notification groups:', error);
          showError('Failed to load notification groups: ' + error);
        })
        .getNotificationGroups();
    }
    
    // Load users for mentions autocomplete
    function loadUsersForMentions() {
      console.log('Loading users for mentions...');
      google.script.run
        .withSuccessHandler(function(users) {
          availableUsers = users || [];
          console.log('Loaded users for mentions:', availableUsers.length);
          console.log('Available users:', availableUsers);
          
          // Initialize mentions autocomplete on all text areas after users are loaded
          initializeMentionsOnAllFields();
        })
        .withFailureHandler(function(error) {
          console.error('Error loading users for mentions:', error);
        })
        .getUsers();
    }
    
    // Initialize mentions autocomplete on all relevant text fields
    function initializeMentionsOnAllFields() {
      console.log('Initializing mentions autocomplete on all fields...');
      
      // Initialize on comment textarea (when modal opens)
      const commentField = document.getElementById('new-comment');
      if (commentField) {
        console.log('Setting up mentions on comment field');
        setupMentionsAutocomplete('new-comment');
      }
      
      // Initialize on description field
      const descField = document.getElementById('item-description');
      if (descField) {
        console.log('Setting up mentions on description field');
        setupMentionsAutocomplete('item-description');
      }
      
      // Initialize on mentions field
      const mentionsField = document.getElementById('item-mentions');
      if (mentionsField) {
        console.log('Setting up mentions on mentions field');
        setupMentionsAutocomplete('item-mentions');
      }
    }
    
    // Setup mentions autocomplete for a textarea
    function setupMentionsAutocomplete(textareaId) {
      console.log('Setting up mentions autocomplete for:', textareaId);
      const textarea = document.getElementById(textareaId);
      if (!textarea) {
        console.log('Textarea not found:', textareaId);
        return;
      }
      
      console.log('Adding input listener to:', textareaId);
      textarea.addEventListener('input', function(e) {
        const text = e.target.value;
        const cursorPos = e.target.selectionStart;
        
        console.log('Input detected:', text, 'cursor at:', cursorPos);
        
        // Find @ symbol before cursor
        const beforeCursor = text.substring(0, cursorPos);
        const atIndex = beforeCursor.lastIndexOf('@');
        
        console.log('Before cursor:', beforeCursor, 'at index:', atIndex);
        
        if (atIndex !== -1) {
          const afterAt = beforeCursor.substring(atIndex + 1);
          console.log('After @:', afterAt);
          
          // Check if we're in the middle of a mention (no spaces after @)
          if (!afterAt.includes(' ') && afterAt.length >= 0) {
            console.log('Showing mention dropdown with query:', afterAt);
            console.log('Available users count:', availableUsers.length);
            showMentionDropdown(textarea, atIndex, afterAt);
            return;
          }
        }
        
        hideMentionDropdown();
      });
      
      textarea.addEventListener('keydown', function(e) {
        if (mentionDropdown && mentionDropdown.style.display === 'block') {
          const items = mentionDropdown.querySelectorAll('.mention-item');
          const selected = mentionDropdown.querySelector('.mention-item.selected');
          
          if (e.key === 'ArrowDown') {
            e.preventDefault();
            selectNextMention(items, selected);
          } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            selectPrevMention(items, selected);
          } else if (e.key === 'Enter' || e.key === 'Tab') {
            e.preventDefault();
            if (selected) {
              insertMention(textarea, selected.dataset.email);
            }
          } else if (e.key === 'Escape') {
            hideMentionDropdown();
          }
        }
      });
    }
    
    // Show mention dropdown
    function showMentionDropdown(textarea, atIndex, query) {
      console.log('showMentionDropdown called with query:', query);
      console.log('Available users:', availableUsers);
      
      if (!mentionDropdown) {
        console.log('Creating mention dropdown');
        createMentionDropdown();
      }
      
      // Filter users based on query
      const filteredUsers = availableUsers.filter(user => {
        const fullName = user.firstName && user.lastName ? `${user.firstName} ${user.lastName}` : user.name || user.displayName || user.email;
        const email = user.email || '';
        const displayName = user.name || user.displayName || '';
        
        console.log('Checking user:', user);
        
        return fullName.toLowerCase().includes(query.toLowerCase()) || 
               email.toLowerCase().includes(query.toLowerCase()) ||
               displayName.toLowerCase().includes(query.toLowerCase());
      }).slice(0, 5); // Limit to 5 results
      
      console.log('Filtered users:', filteredUsers);
      
      if (filteredUsers.length === 0) {
        console.log('No filtered users, hiding dropdown');
        hideMentionDropdown();
        return;
      }
      
      // Populate dropdown
      mentionDropdown.innerHTML = '';
      filteredUsers.forEach((user, index) => {
        const item = document.createElement('div');
        item.className = 'mention-item' + (index === 0 ? ' selected' : '');
        item.dataset.email = user.email;
        
        const fullName = user.firstName && user.lastName ? `${user.firstName} ${user.lastName}` : user.name || user.displayName || user.email;
        const displayName = user.name || fullName || user.email;
        item.innerHTML = `
          <div class="mention-name">${displayName}</div>
          <div class="mention-email">${user.email}</div>
        `;
        
        item.addEventListener('click', () => {
          insertMention(textarea, user.email);
        });
        
        mentionDropdown.appendChild(item);
      });
      
      // Position dropdown with better positioning
      const rect = textarea.getBoundingClientRect();
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
      
      mentionDropdown.style.position = 'fixed';
      mentionDropdown.style.left = rect.left + 'px';
      mentionDropdown.style.top = (rect.bottom + 5) + 'px';
      mentionDropdown.style.zIndex = '9999';
      mentionDropdown.style.display = 'block';
      mentionDropdown.style.maxWidth = '300px';
      mentionDropdown.style.minWidth = '200px';
      
      console.log('Dropdown positioned at:', {
        left: rect.left,
        top: rect.bottom + 5,
        display: mentionDropdown.style.display,
        zIndex: mentionDropdown.style.zIndex
      });
      console.log('Dropdown element:', mentionDropdown);
    }
    
    // Create mention dropdown element
    function createMentionDropdown() {
      mentionDropdown = document.createElement('div');
      mentionDropdown.className = 'mention-dropdown';
      mentionDropdown.style.display = 'none';
      document.body.appendChild(mentionDropdown);
    }
    
    // Hide mention dropdown
    function hideMentionDropdown() {
      if (mentionDropdown) {
        mentionDropdown.style.display = 'none';
      }
    }
    
    // Insert mention into textarea
    function insertMention(textarea, email) {
      const text = textarea.value;
      const cursorPos = textarea.selectionStart;
      const beforeCursor = text.substring(0, cursorPos);
      const afterCursor = text.substring(cursorPos);
      
      const atIndex = beforeCursor.lastIndexOf('@');
      const beforeAt = text.substring(0, atIndex);
      
      textarea.value = beforeAt + '@' + email + ' ' + afterCursor;
      textarea.focus();
      
      const newCursorPos = atIndex + email.length + 2;
      textarea.setSelectionRange(newCursorPos, newCursorPos);
      
      hideMentionDropdown();
    }
    
    // Navigation helpers
    function selectNextMention(items, selected) {
      if (!selected) {
        if (items[0]) items[0].classList.add('selected');
      } else {
        selected.classList.remove('selected');
        const next = selected.nextElementSibling || items[0];
        next.classList.add('selected');
      }
    }
    
    function selectPrevMention(items, selected) {
      if (!selected) {
        if (items.length > 0) items[items.length - 1].classList.add('selected');
      } else {
        selected.classList.remove('selected');
        const prev = selected.previousElementSibling || items[items.length - 1];
        prev.classList.add('selected');
      }
    }
    
    // Add comment (fixed version)
    function addComment() {
      const commentTextarea = document.getElementById('new-comment');
      const commentText = commentTextarea.value.trim();
      
      if (!commentText) {
        alert('Please enter a comment');
        return;
      }
      
      if (!currentActionItemId) {
        alert('No action item selected');
        return;
      }
      
      // Disable the textarea and show loading state
      commentTextarea.disabled = true;
      const postButton = document.getElementById('post-comment-btn');
      const originalButtonText = postButton.innerHTML;
      postButton.disabled = true;
      postButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Posting...';
      
      const commentData = {
        content: commentText,
        author: getCurrentUserEmail()
      };
      
      google.script.run
        .withSuccessHandler(function(savedComment) {
          console.log('Comment added:', savedComment);
          commentTextarea.value = ''; // Clear the textarea
          loadCommentsForItem(currentActionItemId); // Reload comments
          // Re-enable the textarea and reset button
          commentTextarea.disabled = false;
          postButton.disabled = false;
          postButton.innerHTML = originalButtonText;
          commentTextarea.focus();
        })
        .withFailureHandler(function(error) {
          console.error('Error adding comment:', error);
          // Re-enable the textarea and reset button on error
          commentTextarea.disabled = false;
          postButton.disabled = false;
          postButton.innerHTML = originalButtonText;
          alert('Error adding comment: ' + error);
        })
        .addCommentToActionItem(currentActionItemId, commentData);
    }

    // Show spinner
    function showSpinner(message) {
      document.getElementById('spinner-overlay').classList.remove('hidden');
      document.getElementById('spinner-message').textContent = message || 'Loading...';
    }
    
    // Hide spinner
    function hideSpinner() {
      document.getElementById('spinner-overlay').classList.add('hidden');
    }
    
    // Render templates
    function renderTemplates(templates) {
      const templatesContainer = document.getElementById('templates-container');
      
      if (!templates || templates.length === 0) {
        templatesContainer.innerHTML = '<div class="empty-state">No templates found</div>';
        return;
      }
      
      templatesContainer.innerHTML = templates.map(template => `
        <div class="item-card template-card" data-id="${template.actionItemId}">
          <div class="item-info">
            <div class="item-title">${template.title}</div>
            <div class="item-meta">
              ${template.categoryPath ? `<span>Category: ${template.categoryPath}</span>` : ''}
              ${template.priority ? `<span>Priority: ${template.priority}</span>` : ''}
            </div>
          </div>
          <div class="item-actions">
            <button class="action-btn" data-action="use">Use</button>
            <button class="action-btn" data-action="edit">Edit</button>
            <button class="action-btn" data-action="delete">Delete</button>
          </div>
        </div>
      `).join('');
      
      // Add click event listeners to template cards
      document.querySelectorAll('.template-card').forEach(card => {
        card.addEventListener('click', function(event) {
          if (!event.target.closest('.item-actions')) {
            const templateId = this.dataset.id;
            openItemDetails(templateId);
          }
        });
      });
      
      // Add click event listeners to action buttons
      document.querySelectorAll('.template-card .action-btn').forEach(btn => {
        btn.addEventListener('click', function(event) {
          event.stopPropagation();
          const templateId = this.closest('.template-card').dataset.id;
          const action = this.dataset.action;
          
          if (action === 'edit') {
            openItemDetails(templateId);
          } else if (action === 'delete') {
            confirmDeleteItem(templateId);
          } else if (action === 'use') {
            useTemplate(templateId);
          }
        });
      });
    }
    
    // Helper function to calculate due date from timeframe
    function calculateDueDateFromTimeframe(timeframe) {
      if (!timeframe) return '';
      
      const now = new Date();
      const timeframeStr = timeframe.toString().toLowerCase().trim();
      
      // Parse different timeframe formats
      let days = 0;
      
      if (timeframeStr.includes('day')) {
        const match = timeframeStr.match(/(\d+)\s*days?/);
        if (match) days = parseInt(match[1]);
      } else if (timeframeStr.includes('week')) {
        const match = timeframeStr.match(/(\d+)\s*weeks?/);
        if (match) days = parseInt(match[1]) * 7;
      } else if (timeframeStr.includes('month')) {
        const match = timeframeStr.match(/(\d+)\s*months?/);
        if (match) days = parseInt(match[1]) * 30; // Approximate
      } else if (timeframeStr.includes('hour')) {
        const match = timeframeStr.match(/(\d+)\s*hours?/);
        if (match) {
          const hours = parseInt(match[1]);
          if (hours < 24) days = 1; // Same day if less than 24 hours
          else days = Math.ceil(hours / 24);
        }
      } else {
        // Try to parse as just a number (assume days)
        const match = timeframeStr.match(/^(\d+)$/);
        if (match) days = parseInt(match[1]);
      }
      
      if (days > 0) {
        const dueDate = new Date(now);
        dueDate.setDate(dueDate.getDate() + days);
        return dueDate.toISOString().split('T')[0]; // Return YYYY-MM-DD format
      }
      
      return '';
    }
    
    // Function to use a template's data to populate the form
    function useTemplate(templateData) {
      console.log('Populating form from template data:', templateData);

      // --- Field Population ---
      const form = document.getElementById('item-form');
      form.querySelector('#item-title').value = templateData.title || '';
      form.querySelector('#item-description').value = templateData.description || '';
      form.querySelector('#item-status').value = templateData.defaultStatus || 'Open';
      form.querySelector('#item-priority').value = templateData.defaultPriority || 'Medium';
      form.querySelector('#item-assignee').value = templateData.defaultAssignee || '';
      form.querySelector('#item-tags').value = templateData.defaultTags || '';
      form.querySelector('#item-mentions').value = templateData.defaultMentions || '';
      form.querySelector('#item-diagnosis-code').value = templateData.diagnosisCode || '';
      form.querySelector('#item-diagnosis-name').value = templateData.diagnosisName || '';
      
      // Calculate and populate due date from defaultDueTimeframe
      const calculatedDueDate = calculateDueDateFromTimeframe(templateData.defaultDueTimeframe);
      form.querySelector('#item-due-date').value = calculatedDueDate;

      // --- Editability Logic ---
      const fields = ['title', 'description', 'status', 'priority', 'assignee', 'tags', 'mentions', 'diagnosisCode', 'diagnosisName'];
      fields.forEach(field => {
        const element = form.querySelector(`#item-${field.replace(/([A-Z])/g, '-$1').toLowerCase()}`);
        // Correctly check for the readOnly property, e.g., 'readOnly_title'
        const isReadOnly = templateData[`readOnly_${field}`] === true || String(templateData[`readOnly_${field}`]).toUpperCase() === 'TRUE';
        if (element) {
          element.readOnly = isReadOnly;
          element.classList.toggle('readonly', isReadOnly);
        }
      });

      // --- Hide Category Selectors ---
      const categoryContainer = document.getElementById('category-container');
      if(categoryContainer) {
        categoryContainer.style.display = 'none'; // Hide the dropdowns as the choice is made
      }
    }
    
    // Function to confirm deletion of an item
    function confirmDeleteItem(itemId) {
      if (confirm('Are you sure you want to delete this item?')) {
        deleteItem(itemId);
      }
    }
    
    // Function to delete an item
    function deleteItem(itemId) {
      showSpinner('Deleting item...');
      
      google.script.run
        .withSuccessHandler(function() {
          loadActionItems();
          hideSpinner();
        })
        .withFailureHandler(function(error) {
          console.error('Error deleting item:', error);
          hideSpinner();
          alert('Error deleting item: ' + error);
        })
        .deleteActionItem(itemId);
    }
    
    // Function to render options tree
    function renderOptionsTree() {
      const taskOptionsTree = document.getElementById('task-options-tree');
      const orderOptionsTree = document.getElementById('order-options-tree');
      
      if (!actionItemOptions || !actionItemOptions.Task || !actionItemOptions.Order) {
        taskOptionsTree.innerHTML = '<div class="empty-state">No task options found</div>';
        orderOptionsTree.innerHTML = '<div class="empty-state">No order options found</div>';
        return;
      }
      
      // Render task options
      taskOptionsTree.innerHTML = renderCategoryTree(actionItemOptions.Task.categories);
      
      // Render order options
      orderOptionsTree.innerHTML = renderCategoryTree(actionItemOptions.Order.categories);
      
      // Add event listeners to tree nodes
      document.querySelectorAll('.tree-node-toggle').forEach(toggle => {
        toggle.addEventListener('click', function() {
          const node = this.closest('.tree-node');
          node.classList.toggle('expanded');
          this.textContent = node.classList.contains('expanded') ? '−' : '+';
        });
      });
    }
    
    function renderCategoryTree(categories) {
      let html = '';
      for (const key in categories) {
        const category = categories[key];
        const hasSubcategories = category.subcategories && Object.keys(category.subcategories).length > 0;
        const hasOptions = category.options && category.options.length > 0;
        html += `
          <div class="tree-node">
            <div class="tree-node-content">
              ${(hasSubcategories || hasOptions) ? `<span class="tree-node-toggle">+</span>` : '<span class="tree-node-toggle" style="visibility:hidden">+</span>'}
              <span class="tree-node-label">${category.title}</span>
            </div>
            ${(hasSubcategories || hasOptions) ? `
              <div class="tree-node-children">
                ${hasSubcategories ? renderCategoryTree(category.subcategories) : ''}
                ${hasOptions ? category.options.map(option => `
                  <div class="tree-node option-node">
                    <div class="tree-node-content">
                      <span class="tree-node-toggle" style="visibility:hidden">+</span>
                      <span class="tree-node-label">${option.title || option}</span>
                    </div>
                  </div>
                `).join('') : ''}
              </div>
            ` : ''}
          </div>
        `;
      }
      return html;
    }

    // Generates the HTML for a single action item
    function generateActionItemHTML(item) {
      let html = `
        <div class="action-item" data-id="${item.id}">
          <div class="admin-actions">
          <button class="btn btn-primary" onclick="loadUsers()">
            <i class="fas fa-users"></i> Users
          </button>
          <button class="btn btn-secondary" onclick="loadGroups()">
            <i class="fas fa-user-friends"></i> Groups
          </button>
          <button class="btn btn-info" onclick="loadMemberships()">
            <i class="fas fa-link"></i> Memberships
          </button>
        </div>
          <div class="item-body">
            <p>${item.description}</p>
            <p><strong>Status:</strong> ${item.status}</p>
            <p><strong>Assigned To:</strong> ${item.assignee}</p>
            <p><strong>Due:</strong> ${item.dueDate ? new Date(item.dueDate).toLocaleDateString() : 'Not set'}</p>
            ${item.tags ? `<p><strong>Tags:</strong> ${item.tags}</p>` : ''}
          </div>
        </div>`;
      return html;
    }

    document.addEventListener('DOMContentLoaded', function() {
      // This listener handles changes for all current and future category dropdowns
      document.body.addEventListener('change', function(event) {
        if (event.target.matches('.category-dropdown')) {
          handleCategoryChange(event);
        }
      });
    });

    // =================================================================================
// CARE COORDINATOR WORKFLOW FUNCTIONS
// =================================================================================

// Advanced filtering for Care Coordinator workflow
function applyAdvancedFilters() {
  const assignmentFilter = document.getElementById('assignment-filter').value;
  const createdByFilter = document.getElementById('created-by-filter').value;
  const statusFilter = document.getElementById('status-filter').value;
  const priorityFilter = document.getElementById('priority-filter').value;
  const dueDateFilter = document.getElementById('due-date-filter').value;
  const categoryFilter = document.getElementById('category-filter').value;
  const searchTerm = document.getElementById('search-input').value.toLowerCase();
  
  console.log('Applying filters:', { assignmentFilter, createdByFilter, statusFilter, priorityFilter, dueDateFilter, categoryFilter, searchTerm });
      
  const container = document.getElementById('my-items-container');
  const items = container.querySelectorAll('.action-item');
      
  items.forEach(item => {
    let show = true;
    const itemId = item.dataset.itemId;
    const itemData = actionItems.find(i => i.actionItemId === itemId);
    
    if (!itemData) {
      console.warn('Item data not found for:', itemId);
      item.style.display = 'none';
      return;
    }
    
    // Assignment filter
    if (assignmentFilter !== 'all') {
      const currentUser = getCurrentUserEmail();
      const assignedTo = itemData.assignedTo;
      
      switch (assignmentFilter) {
        case 'assigned-to-me':
          show = show && (assignedTo === currentUser);
          break;
        case 'unassigned':
          show = show && (!assignedTo || assignedTo === '');
          break;
        case 'assigned-to-others':
          show = show && (assignedTo && assignedTo !== currentUser);
          break;
        default:
          // Handle specific user assignment (e.g., "john@example.com")
          show = show && (assignedTo === assignmentFilter);
          break;
      }
    }
    
    // Created By filter
    if (createdByFilter !== 'all') {
      show = show && (itemData.createdBy === createdByFilter);
    }
        
        // Status filter
        if (statusFilter !== 'all') {
          show = show && (itemData.status === statusFilter);
        }
        
        // Priority filter
        if (priorityFilter !== 'all') {
          show = show && (itemData.priority === priorityFilter);
        }
        
        // Due date filter
        if (dueDateFilter !== 'all') {
          show = show && matchesDueDateFilter(itemData.dueDate, dueDateFilter);
        }
        
        // Category filter (Level 1 only)
        if (categoryFilter !== 'all') {
          const firstCategoryPart = itemData.categoryPath ? itemData.categoryPath.split('/')[0] : '';
          const level1Category = firstCategoryPart ? firstCategoryPart.trim() : '';
          show = show && (level1Category === categoryFilter);
        }
        
        // Search filter
        if (searchTerm) {
          const searchableText = (
            itemData.title + ' ' + 
            itemData.description + ' ' + 
            itemData.assignedTo + ' ' + 
            itemData.categoryPath
          ).toLowerCase();
          show = show && searchableText.includes(searchTerm);
        }
        
        item.style.display = show ? 'block' : 'none';
      });
      
      updateFilterResultsCount();
    }
    
    // Helper function to extract item data from DOM element
    function getItemDataFromElement(itemElement) {
      const getTextContent = (selector) => {
        const el = itemElement.querySelector(selector);
        return el ? el.textContent : '';
      };
      
      return {
        id: itemElement.dataset.id || '',
        title: getTextContent('.item-title'),
        description: getTextContent('.item-description'),
        status: getTextContent('.item-status'),
        priority: getTextContent('.item-priority'),
        assignedTo: getTextContent('.item-assignee'),
        dueDate: getTextContent('.item-due-date'),
        categoryPath: getTextContent('.item-category')
      };
    }
    
    // Helper function to match due date filters
    function matchesDueDateFilter(dueDate, filter) {
      if (!dueDate) return false;
      
      const itemDate = new Date(dueDate);
      const today = new Date();
      const todayStart = new Date(today.getFullYear(), today.getMonth(), today.getDate());
      
      switch (filter) {
        case 'overdue':
          return itemDate < todayStart;
        case 'today':
          return itemDate.toDateString() === today.toDateString();
        case 'this-week':
          const weekEnd = new Date(todayStart);
          weekEnd.setDate(weekEnd.getDate() + 7);
          return itemDate >= todayStart && itemDate < weekEnd;
        case 'next-week':
          const nextWeekStart = new Date(todayStart);
          nextWeekStart.setDate(nextWeekStart.getDate() + 7);
          const nextWeekEnd = new Date(nextWeekStart);
          nextWeekEnd.setDate(nextWeekEnd.getDate() + 7);
          return itemDate >= nextWeekStart && itemDate < nextWeekEnd;
        default:
          return true;
      }
    }
    
    // Clear all filters for My Items tab
    function clearAllFilters() {
      document.getElementById('assignment-filter').value = 'all';
      document.getElementById('created-by-filter').value = 'all';
      document.getElementById('status-filter').value = 'all';
      document.getElementById('priority-filter').value = 'all';
      document.getElementById('due-date-filter').value = 'all';
      document.getElementById('category-filter').value = 'all';
      document.getElementById('search-input').value = '';
      applyAdvancedFilters();
    }

    // Clear all filters for All Items tab
    function clearAllFiltersAll() {
      document.getElementById('assignment-filter-all').value = 'all';
      document.getElementById('created-by-filter-all').value = 'all';
      document.getElementById('status-filter-all').value = 'all';
      document.getElementById('priority-filter-all').value = 'all';
      document.getElementById('due-date-filter-all').value = 'all';
      document.getElementById('category-filter-all').value = 'all';
      document.getElementById('search-input-all').value = '';
      renderActionItems();
    }
    
    // Self-assign selected items
    function selfAssignSelected() {
      const selectedItems = document.querySelectorAll('.action-item input[type="checkbox"]:checked');
      if (selectedItems.length === 0) {
        alert('Please select items to self-assign.');
        return;
      }
      
      const currentUser = getCurrentUserEmail();
      const itemIds = Array.from(selectedItems).map(checkbox => checkbox.closest('.action-item').dataset.itemId);
      
      if (confirm(`Self-assign ${itemIds.length} item(s) to yourself?`)) {
        bulkAssignItems(itemIds, currentUser);
      }
    }
    
    // Bulk assign items
    function bulkAssignItems(itemIds, assignee) {
      showSpinner('Assigning items...');
      
      google.script.run
        .withSuccessHandler(function(result) {
          console.log('Items assigned:', result);
          loadActionItems(); // Refresh the list
          hideSpinner();
          alert(`Successfully assigned ${itemIds.length} item(s).`);
        })
        .withFailureHandler(function(error) {
          console.error('Error assigning items:', error);
          hideSpinner();
          alert('Error assigning items: ' + error);
        })
        .bulkAssignItems(itemIds, assignee);
    }
    
    // Get current user email
    function getCurrentUserEmail() {
      return currentUser || 'unknown@example.com'; // Fallback
    }
    
    // Ensure category data is loaded before proceeding
    function ensureCategoryDataLoaded() {
      return new Promise((resolve, reject) => {
        // Check if data is already loaded
        if (actionItemOptions && actionItemOptions.actionItems && actionItemOptions.actionItems.categories) {
          console.log('Category data already loaded');
          resolve();
          return;
        }
        
        console.log('Category data not loaded, loading now...');
        
        // Load the data
        loadActionItemOptions(() => {
          // Double-check that data is now loaded
          if (actionItemOptions && actionItemOptions.actionItems && actionItemOptions.actionItems.categories) {
            console.log('Category data successfully loaded');
            resolve();
          } else {
            console.error('Failed to load category data');
            reject(new Error('Failed to load category data'));
          }
        });
      });
    }
    
    // Update filter results count
    function updateFilterResultsCount() {
      const container = document.getElementById('my-items-container');
      const visibleItems = container.querySelectorAll('.action-item:not([style*="display: none"])');
      const totalItems = container.querySelectorAll('.action-item');
      
      // Add or update results count display
      let countDisplay = document.getElementById('filter-results-count');
      if (!countDisplay) {
        countDisplay = document.createElement('div');
        countDisplay.id = 'filter-results-count';
        countDisplay.style.cssText = 'margin: 10px 0; font-size: 14px; color: #666;';
        container.parentNode.insertBefore(countDisplay, container);
      }
      
      countDisplay.textContent = `Showing ${visibleItems.length} of ${totalItems.length} items`;
    }
    
    // Apply filters for All Items tab (legacy function)
    function applyFiltersAll() {
      const statusFilter = document.getElementById('status-filter-all').value;
      const searchTerm = document.getElementById('search-input-all').value.toLowerCase();
      
      const container = document.getElementById('all-items-container');
      const items = container.querySelectorAll('.action-item');
      
      items.forEach(item => {
        let show = true;
        const itemData = getItemDataFromElement(item);
        
        // Status filter
        if (statusFilter !== 'all') {
          show = show && (itemData.status === statusFilter);
        }
        
        // Search filter
        if (searchTerm) {
          const searchableText = (
            itemData.title + ' ' + 
            itemData.description + ' ' + 
            itemData.assignedTo + ' ' + 
            itemData.categoryPath
          ).toLowerCase();
          show = show && searchableText.includes(searchTerm);
        }
        
        item.style.display = show ? 'block' : 'none';
      });
    }
    
    // =================================================================================
    // ADMIN FUNCTIONS
    // =================================================================================
    
    // Load users for admin management
    function loadUsers() {
      const tbody = document.getElementById('users-table-body');
      tbody.innerHTML = '<tr><td colspan="4">Loading users...</td></tr>';
      
      google.script.run
        .withSuccessHandler(function(users) {
          console.log('Users loaded:', users);
          displayUsers(users);
        })
        .withFailureHandler(function(error) {
          console.error('Error loading users:', error);
          tbody.innerHTML = '<tr><td colspan="4">Error loading users: ' + error + '</td></tr>';
        })
        .getUsers();
    }
    
    // Display users in the admin table
    function displayUsers(users) {
      const tbody = document.getElementById('users-table-body');
      
      if (!users || users.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5">No users found.</td></tr>';
        return;
      }
      
      tbody.innerHTML = users.map(user => {
        // Handle both new and legacy field names
        const email = user.email || '';
        const firstName = user.firstName || user.staffFirstName || '';
        const lastName = user.lastName || user.staffLastName || '';
        const displayName = user.displayName || 
                          (firstName && lastName ? `${firstName} ${lastName}`.trim() : 
                          user.name || email.split('@')[0]);
        const role = (user.role || 'user').toLowerCase();
        const isActive = user.active !== undefined ? user.active : 
                        (user.Isactive !== undefined ? user.Isactive : true);
        
        return `
          <tr data-email="${email}" class="${isActive ? '' : 'inactive-user'}">
            <td>${displayName || 'N/A'}</td>
            <td>${email}</td>
            <td>${firstName}</td>
            <td>${lastName}</td>
            <td>${role.charAt(0).toUpperCase() + role.slice(1)}</td>
            <td>${isActive ? 'Active' : 'Inactive'}</td>
            <td class="actions">
              <button class="secondary-btn" onclick="editUser('${email}')">Edit</button>
              <button class="danger-btn" onclick="deleteUser('${email}')">Delete</button>
            </td>
          </tr>
        `;
      }).join('');
    }
    
    // Load groups for admin management
    function loadGroups() {
      const tbody = document.getElementById('groups-table-body');
      tbody.innerHTML = '<tr><td colspan="4">Loading groups...</td></tr>';
      
      google.script.run
        .withSuccessHandler(function(groups) {
          console.log('Groups loaded:', groups);
          displayGroups(groups);
        })
        .withFailureHandler(function(error) {
          console.error('Error loading groups:', error);
          tbody.innerHTML = '<tr><td colspan="4">Error loading groups: ' + error + '</td></tr>';
        })
        .getNotificationGroups();
    }
    
    // Display groups in the admin table
    function displayGroups(groups) {
      const tbody = document.getElementById('groups-table-body');
      
      if (!groups || groups.length === 0) {
        tbody.innerHTML = '<tr><td colspan="4">No groups found.</td></tr>';
        return;
      }
      
      tbody.innerHTML = groups.map(group => `
        <tr>
          <td>${group.groupName || 'N/A'}</td>
          <td>${group.groupId || 'N/A'}</td>
          <td>${group.webhookUrl ? 'Configured' : 'Not configured'}</td>
          <td>
            <button class="secondary-btn" onclick="editGroup('${group.groupId}')">Edit</button>
            <button class="danger-btn" onclick="deleteGroup('${group.groupId}')">Delete</button>
          </td>
        </tr>
      `).join('');
    }
    
    // Admin modal functions
    function showUserModal(isEdit = false, userData = null) {
      console.log('showUserModal called with:', { isEdit, userData });
      const modal = document.getElementById('user-modal');
      const title = document.getElementById('user-modal-title');
      const form = document.getElementById('user-form');
      
      if (!modal || !title || !form) {
        console.error('Required modal elements not found:', { 
          modal: !!modal, 
          title: !!title, 
          form: !!form
        });
        return;
      }
      
      // Get all form fields first
      const editEmailInput = document.getElementById('edit-email') || {};
      const emailInput = document.getElementById('user-email-input');
      const firstNameInput = document.getElementById('user-first-name');
      const lastNameInput = document.getElementById('user-last-name');
      const displayNameInput = document.getElementById('user-display-name');
      const roleSelectElement = document.getElementById('user-role');
      const webhookInput = document.getElementById('user-webhook');
      const activeCheckboxElement = document.getElementById('user-active');
      
      // Reset the form and set up initial state
      form.reset();
      
      // Set up email field state based on add/edit mode
      if (emailInput) {
        if (isEdit) {
          // When editing, disable the email field
          emailInput.disabled = true;
          emailInput.required = false;
          // Clear the hidden edit-email field
          if (editEmailInput) editEmailInput.value = '';
        } else {
          // When adding, enable the email field and make it required
          emailInput.disabled = false;
          emailInput.required = true;
          emailInput.value = ''; // Clear any previous value
        }
      }
      
      if (isEdit && userData) {
        console.log('Editing user with data:', JSON.stringify(userData, null, 2));
        title.textContent = 'Edit User';
        
        // Set all fields from userData with fallbacks for legacy field names
        const email = userData.email || '';
        const firstName = userData.firstName || userData.staffFirstName || '';
        const lastName = userData.lastName || userData.staffLastName || '';
        const displayName = userData.displayName || 
                          (firstName && lastName ? `${firstName} ${lastName}`.trim() : 
                          userData.name || (email ? email.split('@')[0] : ''));
        
        // Set email field with debug logging
      console.log('Setting email field. emailInput exists:', !!emailInput, 'email:', email);
      
      // Set the hidden email field for form submission
      if (editEmailInput) {
        console.log('Setting editEmailInput value to:', email);
        editEmailInput.value = email;
      }
      
      // Set the email input field
      if (emailInput) {
        console.log('Setting email input value to:', email);
        emailInput.value = email;
        
        // Disable email field when editing
        if (isEdit) {
          emailInput.disabled = true;
        } else {
          emailInput.disabled = false;
          emailInput.required = true;
        }
        
        // Make sure the input is visible
        emailInput.style.display = 'block';
        emailInput.style.visibility = 'visible';
        emailInput.style.opacity = '1';
        
        // Find and show the form group in the modal
        const formGroup = emailInput.closest('.form-group');
        if (formGroup) {
          console.log('Found form group in modal:', formGroup);
          formGroup.style.display = 'block';
          formGroup.style.visibility = 'visible';
          formGroup.style.opacity = '1';
          formGroup.style.height = 'auto';
          formGroup.style.overflow = 'visible';
        }
      } else {
        console.error('Email input element not found');
      }
        
        // Ensure the modal content is visible
        const modalContent = document.querySelector('#user-modal .modal-content');
        if (modalContent) {
          modalContent.style.display = 'block';
          console.log('Modal content made visible');
        }
        
        // Set other fields
        if (firstNameInput) firstNameInput.value = firstName || '';
        if (lastNameInput) lastNameInput.value = lastName || '';
        if (displayNameInput) displayNameInput.value = displayName || '';
        
        // Set role, defaulting to 'user' if not specified (lowercase for consistency)
        if (roleSelectElement) {
          roleSelectElement.value = (userData.role || 'user').toLowerCase();
        }
        
        // Set webhook URL (check both possible property names)
        if (webhookInput) {
          webhookInput.value = userData.webhookUrl || userData.Chatwebhook || '';
        }
        
        // Set active status (default to true if not specified)
        if (activeCheckboxElement) {
          const isActive = userData.active !== undefined ? userData.active : 
                         (userData.Isactive !== undefined ? userData.Isactive : true);
          activeCheckboxElement.checked = isActive;
        }
        
        // Disable email field when editing
        if (emailInput) {
          emailInput.disabled = true;
        }
      } else {
        console.log('Adding new user');
        title.textContent = 'Add User';
        
        // Enable and clear the email field for new users
        const emailInput = document.getElementById('user-email');
        if (emailInput) {
          emailInput.disabled = false;
          emailInput.value = '';
          emailInput.required = true;
          
          // Make sure the email field is visible and enabled
          emailInput.style.display = 'block';
          emailInput.style.visibility = 'visible';
          emailInput.style.opacity = '1';
          
          // Make sure the form group is visible
          const formGroup = emailInput.closest('.form-group');
          if (formGroup) {
            formGroup.style.display = 'block';
            formGroup.style.visibility = 'visible';
            formGroup.style.opacity = '1';
            formGroup.style.height = 'auto';
            formGroup.style.overflow = 'visible';
          }
        }
        
        // Set default active state
        const activeCheckbox = document.getElementById('user-active');
        if (activeCheckbox) {
          activeCheckbox.checked = true;
        }
      }
      
      // Show the modal
      modal.style.display = 'block';
    }
    
    function closeUserModal() {
      document.getElementById('user-modal').style.display = 'none';
    }
    
    function showGroupModal(isEdit = false, groupData = null) {
      const modal = document.getElementById('group-modal');
      const title = document.getElementById('group-modal-title');
      const form = document.getElementById('group-form');
      
      // Reset form
      form.reset();
      document.getElementById('edit-group-name').value = '';
      
      if (isEdit && groupData) {
        title.textContent = 'Edit Group';
        document.getElementById('edit-group-name').value = groupData.groupName;
        document.getElementById('group-name').value = groupData.groupName;
        document.getElementById('group-id').value = groupData.groupId || '';
        document.getElementById('group-webhook').value = groupData.webhookUrl || '';
        
        // Disable group name field when editing
        document.getElementById('group-name').disabled = true;
      } else {
        title.textContent = 'Create Group';
        document.getElementById('group-name').disabled = false;
      }
      
      // Load user checkboxes for group membership
      populateGroupMemberCheckboxes(groupData ? groupData.members : []);
      
      modal.style.display = 'block';
    }
    
    function closeGroupModal() {
      document.getElementById('group-modal').style.display = 'none';
    }
    
    function populateGroupMemberCheckboxes(selectedMembers = []) {
      const container = document.getElementById('group-members-checkboxes');
      container.innerHTML = '<p>Loading users...</p>';
      
      google.script.run
        .withSuccessHandler(function(users) {
          if (!users || users.length === 0) {
            container.innerHTML = '<p>No users available</p>';
            return;
          }
          
          container.innerHTML = users.map(user => {
            const isSelected = selectedMembers.includes(user.email);
            return `
              <label class="checkbox-item">
                <input type="checkbox" value="${user.email}" ${isSelected ? 'checked' : ''}>
                ${user.firstName && user.lastName ? user.firstName + ' ' + user.lastName : user.name || user.displayName || user.email} (${user.email})
              </label>
            `;
          }).join('');
        })
        .withFailureHandler(function(error) {
          container.innerHTML = '<p>Error loading users: ' + error + '</p>';
        })
        .getUsers();
    }
    
    function showConfirmModal(message, onConfirm) {
      document.getElementById('confirm-message').textContent = message;
      const modal = document.getElementById('confirm-modal');
      const confirmBtn = document.getElementById('confirm-action-btn');
      
      // Remove existing event listeners
      const newConfirmBtn = confirmBtn.cloneNode(true);
      confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
      
      // Add new event listener
      newConfirmBtn.addEventListener('click', function() {
        onConfirm();
        closeConfirmModal();
      });
      
      modal.style.display = 'block';
    }
    
    function closeConfirmModal() {
      document.getElementById('confirm-modal').style.display = 'none';
    }
    
    // Admin UI event handlers
    function editUser(email) {
      // Find user data and show edit modal
      google.script.run
        .withSuccessHandler(function(users) {
          const user = users.find(u => u.email === email);
          if (user) {
            showUserModal(true, user);
          } else {
            alert('User not found');
          }
        })
        .withFailureHandler(function(error) {
          alert('Error loading user data: ' + error);
        })
        .getUsers();
    }
    
    function deleteUser(email) {
      showConfirmModal(
        `Are you sure you want to delete user: ${email}? This action cannot be undone.`,
        function() {
          google.script.run
            .withSuccessHandler(function() {
              alert('User deleted successfully');
              loadUsers();
            })
            .withFailureHandler(function(error) {
              alert('Error deleting user: ' + error);
            })
            .deleteUser(email);
        }
      );
    }
    
    function editGroup(groupId) {
      // Find group data and show edit modal
      google.script.run
        .withSuccessHandler(function(groups) {
          const group = groups.find(g => g.groupId === groupId);
          if (group) {
            showGroupModal(true, group);
          } else {
            alert('Group not found');
          }
        })
        .withFailureHandler(function(error) {
          alert('Error loading group data: ' + error);
        })
        .getNotificationGroups();
    }
    
    function deleteGroup(groupId) {
      showConfirmModal(
        `Are you sure you want to delete group: ${groupId}? This action cannot be undone.`,
        function() {
          google.script.run
            .withSuccessHandler(function() {
              alert('Group deleted successfully');
              loadGroups();
            })
            .withFailureHandler(function(error) {
              alert('Error deleting group: ' + error);
            })
            .deleteGroup(groupId);
        }
      );
    }
    
    // Save user function
    function saveUser() {
      const saveBtn = document.getElementById('save-user-btn');
      const originalBtnText = saveBtn.textContent;
      saveBtn.disabled = true;
      saveBtn.textContent = 'Saving...';
      
      // Get form values with null checks and safe trimming
      const emailInput = document.getElementById('user-email-input');
      const firstNameInput = document.getElementById('user-first-name');
      const lastNameInput = document.getElementById('user-last-name');
      const displayNameInput = document.getElementById('user-display-name');
      const roleSelect = document.getElementById('user-role');
      const webhookInput = document.getElementById('user-webhook');
      const activeCheckbox = document.getElementById('user-active');
      const editEmailInput = document.getElementById('edit-email');
      
      // Debug: Log all form field values
      console.log('Form field values:', {
        emailInput: emailInput ? emailInput.value : 'null',
        firstNameInput: firstNameInput ? firstNameInput.value : 'null',
        lastNameInput: lastNameInput ? lastNameInput.value : 'null',
        displayNameInput: displayNameInput ? displayNameInput.value : 'null',
        roleSelect: roleSelect ? roleSelect.value : 'null',
        webhookInput: webhookInput ? webhookInput.value : 'null',
        activeCheckbox: activeCheckbox ? activeCheckbox.checked : 'null',
        editEmailInput: editEmailInput ? editEmailInput.value : 'null'
      });
      
      // Get values with null checks and safe trimming
      let email = '';
      if (editEmailInput && editEmailInput.value) {
        // If editing, use the edit-email field
        email = editEmailInput.value.trim();
      } else if (emailInput) {
        // If adding new, use the user-email field
        email = emailInput.value ? emailInput.value.trim() : '';
      }
      const firstName = firstNameInput ? (firstNameInput.value || '').trim() : '';
      const lastName = lastNameInput ? (lastNameInput.value || '').trim() : '';
      let displayName = displayNameInput ? (displayNameInput.value || '').trim() : '';
      const role = roleSelect ? (roleSelect.value || 'user').toLowerCase() : 'user';
      const webhookUrl = webhookInput ? (webhookInput.value || '').trim() : '';
      const active = activeCheckbox ? activeCheckbox.checked : true;
      const isEdit = editEmailInput && editEmailInput.value !== '';
      
      console.log('Form values:', {
        email,
        firstName,
        lastName,
        displayName,
        role,
        webhookUrl,
        active,
        isEdit,
        emailInputExists: !!emailInput,
        emailInputValue: emailInput ? emailInput.value : 'undefined',
        emailInputId: emailInput ? emailInput.id : 'undefined',
        emailInputDisabled: emailInput ? emailInput.disabled : 'undefined',
        emailInputStyle: emailInput ? JSON.stringify(emailInput.style) : 'undefined'
      });
      
      // Basic validation
      if (!email) {
        alert('Email is required');
        saveBtn.disabled = false;
        saveBtn.textContent = originalBtnText;
        return;
      }
      
      if (!firstName || !lastName) {
        alert('First name and last name are required');
        saveBtn.disabled = false;
        saveBtn.textContent = originalBtnText;
        return;
      }
      
      // Generate displayName if not provided
      if (!displayName) {
        displayName = `${firstName} ${lastName}`.trim();
      }
      
      const userData = {
        email: email,
        firstName: firstName,
        lastName: lastName,
        displayName: displayName,
        role: role,
        webhookUrl: webhookUrl,
        active: active,
        // Include legacy field names for backward compatibility
        staffFirstName: firstName,
        staffLastName: lastName,
        Chatwebhook: webhookUrl,
        Isactive: active
      };
      
      showSpinner('Saving user...');
      
      if (isEdit) {
        const originalEmail = document.getElementById('edit-email').value;
        google.script.run
          .withSuccessHandler(function() {
            hideSpinner();
            closeUserModal();
            loadUsers();
            loadUsersForMentions();
          })
          .withFailureHandler(function(error) {
            hideSpinner();
            console.error('Error updating user:', error);
            alert('Error updating user: ' + (error.message || 'Unknown error'));
          })
          .saveUser(userData);
      } else {
        google.script.run
          .withSuccessHandler(function() {
            hideSpinner();
            closeUserModal();
            loadUsers();
            loadUsersForMentions();
          })
          .withFailureHandler(function(error) {
            hideSpinner();
            console.error('Error adding user:', error);
            alert('Error adding user: ' + (error.message || 'Unknown error'));
          })
          .saveUser(userData);
      }
    }
    
    // Save group function
    function saveGroup() {
      const saveBtn = document.getElementById('save-group-btn');
      const originalBtnText = saveBtn.textContent;
      saveBtn.disabled = true;
      saveBtn.textContent = 'Saving...';
      
      const isEdit = document.getElementById('edit-group-name').value !== '';
      const selectedMembers = Array.from(document.querySelectorAll('#group-members-checkboxes input[type="checkbox"]:checked'))
        .map(cb => cb.value);
      
      const groupData = {
        groupName: document.getElementById('group-name').value,
        groupId: document.getElementById('group-id').value,
        webhookUrl: document.getElementById('group-webhook').value,
        members: selectedMembers,
        originalName: isEdit ? document.getElementById('edit-group-name').value : null
      };
      
      // Validation
      if (!groupData.groupName) {
        alert('Group name is required.');
        saveBtn.disabled = false;
        saveBtn.textContent = originalBtnText;
        return;
      }
      
      google.script.run
        .withSuccessHandler(function(result) {
          console.log('Group saved:', result);
          closeGroupModal();
          loadGroups();
          alert(isEdit ? 'Group updated successfully' : 'Group created successfully');
        })
        .withFailureHandler(function(error) {
          console.error('Error saving group:', error);
          alert('Error saving group: ' + error);
        })
        .withFinally(function() {
          saveBtn.disabled = false;
          saveBtn.textContent = originalBtnText;
        })
        .saveGroup(groupData, isEdit);
    }

    /**
     * This is the single entry point for handling a selection on ANY category dropdown.
     * It is attached via a delegated event listener on the body.
     */
    function handleCategoryChange(event) {
      const selectElement = event.target;
      const level = parseInt(selectElement.dataset.level, 10);
      const selectedValue = selectElement.value;

      // --- 1. Clear UI State for subsequent levels ---
      let nextLevel = level + 1;
      let nextDropdown;
      while (nextDropdown = document.querySelector(`select[data-level='${nextLevel}']`)) {
        nextDropdown.parentElement.remove(); // Remove the entire form group
        nextLevel++;
      }

      // If the user de-selected an option (chose 'Select...'), we're done.
      if (!selectedValue) {
        return;
      }

      // --- 2. Determine Current State ---
      // Re-build the current category path from the values of all active dropdowns.
      const pathParts = [];
      for (let i = 1; i <= level; i++) {
        const dropdown = document.querySelector(`select[data-level='${i}']`);
        if (dropdown && dropdown.value) {
          pathParts.push(dropdown.value);
        }
      }
      const fullPath = pathParts.join('/');
      console.log(`Current Path: ${fullPath}`);

      // --- 3. Decide Action: Create Next Dropdown or Populate Form ---
      // Traverse the category tree to find the node for the currently selected path.
      let subcategoriesToShow = actionItemOptions.actionItems.categories;
      for (const part of pathParts) {
        if (subcategoriesToShow && subcategoriesToShow[part]) {
          // Move into the subcategories of the selected part for the next iteration/level.
          subcategoriesToShow = subcategoriesToShow[part].subcategories;
        } else {
          // If at any point the path is broken, nullify and exit.
          subcategoriesToShow = null;
          break;
        }
      }

      if (subcategoriesToShow && Object.keys(subcategoriesToShow).length > 0) {
        // A. It's an intermediate category. Create the next dropdown.
        console.log('Intermediate category selected. Creating next dropdown with options:', subcategoriesToShow);
        createCategoryDropdown(level + 1, subcategoriesToShow);
      } else {
        // B. It's a final template. Populate the form fields.
        console.log('Final template selected. Attempting to populate form for path:', fullPath);
        const templateData = actionItemOptions.actionItems.optionsData[fullPath];
        if (templateData) {
          useTemplate(templateData);
        } else {
          console.error('Data Error: No template data found for the final path:', fullPath);
          alert('Could not find template data for ' + fullPath);
        }
      }
    }

    /**
     * Creates and appends a new category dropdown to the container.
     */
    function createCategoryDropdown(level, options) {
      const container = document.getElementById('dynamic-category-container');
      const select = document.createElement('select');
      select.className = 'form-control category-dropdown';
      select.dataset.level = level;

      const defaultOption = document.createElement('option');
      defaultOption.value = '';
      defaultOption.textContent = `Select...`;
      select.appendChild(defaultOption);

      for (const key in options) {
        const option = document.createElement('option');
        option.value = key;
        option.textContent = options[key].title || key;
        select.appendChild(option);
      }

      const formGroup = document.createElement('div');
      formGroup.className = 'form-group';
      formGroup.appendChild(select);
      container.appendChild(formGroup);
    }

    /**
     * Populates the very first category dropdown (Level 1).
     * This is called when the modal is opened.
     */
    function populateTopLevelCategories() {
      console.log('populateTopLevelCategories: Starting to populate categories...');
      const categorySelect = document.getElementById('category-level-1');
      
      if (!categorySelect) {
        console.error('populateTopLevelCategories: Could not find category-level-1 select element');
        return;
      }
      
      // Clear existing options except the first 'Select...' one
      while (categorySelect.options.length > 1) {
        categorySelect.remove(1);
      }
      
      console.log('populateTopLevelCategories: actionItemOptions:', actionItemOptions);
      
      // Get categories from the options data
      const categories = actionItemOptions?.actionItems?.categories || {};
      console.log('populateTopLevelCategories: Available category keys:', Object.keys(categories));
      
      if (!categories || Object.keys(categories).length === 0) {
        console.error('populateTopLevelCategories: No categories available to populate dropdown.');
        categorySelect.disabled = true;
        return;
      }
      
      let optionsAdded = 0;
      
      // Add categories to the dropdown
      for (const categoryKey in categories) {
        if (categories.hasOwnProperty(categoryKey)) {
          const category = categories[categoryKey];
          console.log(`populateTopLevelCategories: Processing category ${categoryKey}:`, category);
          
          // Get the display name - handle both direct string values and objects with title property
          let displayName = categoryKey;
          if (category && typeof category === 'object' && category !== null) {
            displayName = category.title || categoryKey;
          }
          
          if (displayName) {
            const option = document.createElement('option');
            option.value = categoryKey;
            option.textContent = displayName;
            categorySelect.appendChild(option);
            optionsAdded++;
            console.log(`populateTopLevelCategories: Added option: ${categoryKey} = ${displayName}`);
          }
        }
      }
      
      // If we added any options, enable the dropdown
      categorySelect.disabled = optionsAdded === 0;
      console.log(`populateTopLevelCategories: Added ${optionsAdded} categories, dropdown ${categorySelect.disabled ? 'disabled' : 'enabled'}`);
      
      // Force a reflow to ensure the dropdown updates
      void categorySelect.offsetHeight;
    }
    
    // ===== ADMIN FUNCTIONALITY =====
    
    // Initialize admin functionality
    function initAdmin() {
      // First, check if the admin and template tabs exist
      const adminTabButton = document.getElementById('admin-tab');
      const templatesTabButton = document.getElementById('templates-tab');
      
      if (!adminTabButton || !templatesTabButton) {
        console.warn('Tab buttons not found in the DOM');
        return;
      }
      
      // Hide admin and template tabs by default until we verify access
      adminTabButton.style.display = 'none';
      templatesTabButton.style.display = 'none';
      
      // Check if user has admin access
      google.script.run
        .withSuccessHandler(function(isAdminUser) {
          console.log('Admin check result:', isAdminUser);
          if (isAdminUser) {
            // Show the admin and template tab buttons for admin users
            adminTabButton.style.display = 'block';
            templatesTabButton.style.display = 'block';
            console.log('Admin and template tabs shown');
            
            // Load admin data when admin access is confirmed
            setTimeout(() => {
              loadUsers();
              loadGroups();
            }, 100);
          } else {
            // Ensure tabs are hidden for non-admin users
            adminTabButton.style.display = 'none';
            templatesTabButton.style.display = 'none';
            console.log('User does not have admin access - hiding admin and template tabs');
          }
        })
        .withFailureHandler(function(error) {
          console.error('Error checking admin status:', error);
          // Keep admin tab hidden on error
          adminTabButton.style.display = 'none';
        })
        .isAdmin();
        
      // Set up event listeners for admin buttons
      const addUserBtn = document.getElementById('add-user-btn');
      if (addUserBtn) addUserBtn.addEventListener('click', function() {
        showUserModal(false);
      });
      
      const refreshUsersBtn = document.getElementById('refresh-users-btn');
      if (refreshUsersBtn) refreshUsersBtn.addEventListener('click', loadUsers);
      
      const addGroupBtn = document.getElementById('add-group-btn');
      if (addGroupBtn) addGroupBtn.addEventListener('click', function() {
        showGroupModal(false);
      });
      
      const refreshGroupsBtn = document.getElementById('refresh-groups-btn');
      if (refreshGroupsBtn) refreshGroupsBtn.addEventListener('click', loadGroups);
      
      // Webhook test button
      console.log('Initializing webhook test button...');
      const testWebhookBtn = document.getElementById('test-webhook-btn');
      console.log('Button element:', testWebhookBtn);
      
      if (testWebhookBtn) {
        console.log('Found webhook test button, adding click handler');
        
        // Store a reference to the button for debugging
        window.testWebhookBtn = testWebhookBtn;
        
        // Add click handler with detailed logging
        testWebhookBtn.addEventListener('click', function(e) {
          console.log('Webhook test button clicked', e);
          console.log('Button text:', e.target.textContent);
          console.log('Button id:', e.target.id);
          console.log('Button classList:', e.target.classList);
          console.log('Button parent:', e.target.parentElement);
          
          try {
            console.log('Calling showWebhookTestUI...');
            showWebhookTestUI();
            console.log('showWebhookTestUI called successfully');
          } catch (error) {
            console.error('Error in webhook test button click handler:', error);
            showToast('Error: ' + (error.message || 'Unknown error'), 'error');
          }
        });
        
        // Add a test click handler to verify the button is clickable
        testWebhookBtn.addEventListener('mousedown', function() {
          console.log('Webhook test button mousedown event');
        });
        
        // Make the button more visible for testing
        testWebhookBtn.style.border = '2px solid red';
        testWebhookBtn.style.padding = '8px 16px';
        testWebhookBtn.style.borderRadius = '4px';
        
        console.log('Webhook test button initialization complete');
      } else {
        console.error('Could not find webhook test button. Searching for any buttons with similar IDs...');
        
        // Debug: Find all buttons in the document
        const allButtons = document.querySelectorAll('button');
        console.log('All buttons on page:', allButtons);
        
        // Debug: Find any elements with 'webhook' in the ID
        const webhookElements = document.querySelectorAll('[id*="webhook"], [class*="webhook"]');
        console.log('Elements with "webhook" in ID or class:', webhookElements);
        
        showToast('Could not find webhook test button', 'error');
      }
      
      const refreshWebhookBtn = document.getElementById('refresh-webhook-btn');
      if (refreshWebhookBtn) refreshWebhookBtn.addEventListener('click', function() {
        loadUsers();
        showToast('Users refreshed', 'success');
      });
      
      // User form submission
      const userForm = document.getElementById('user-form');
      if (userForm) {
        userForm.addEventListener('submit', function(e) {
          e.preventDefault();
          saveUser();
        });
      } else {
        console.error('User form not found');
      }
      
      const groupForm = document.getElementById('group-form');
      if (groupForm) safeAddEventListener(groupForm, 'submit', function(e) {
        e.preventDefault();
        saveGroup();
      });
      
      // Set up modal close handlers
      document.querySelectorAll('.close-modal').forEach(closeBtn => {
        safeAddEventListener(closeBtn, 'click', function() {
          this.closest('.modal').style.display = 'none';
        });
      });
      
      // Close modals when clicking outside
      safeAddEventListener(window, 'click', function(event) {
        if (event.target.classList.contains('modal')) {
          event.target.style.display = 'none';
        }
      });
      
      const addMembershipBtn = document.getElementById('add-membership-btn');
      if (addMembershipBtn) addMembershipBtn.addEventListener('click', showAddMembershipModal);
      const refreshMembershipsBtn = document.getElementById('refresh-memberships-btn');
      if (refreshMembershipsBtn) refreshMembershipsBtn.addEventListener('click', loadMemberships);
    }
    
    // Show webhook test UI
    function showWebhookTestUI() {
      console.log('showWebhookTestUI called');
      
      // Show loading state
      showToast('Loading webhook test tool...', 'info');
      
      // First, verify we can call the server
      console.log('Testing server connection...');
      google.script.run
        .withSuccessHandler(function(testResult) {
          console.log('Server connection test successful:', testResult);
          
          // Now try to load the webhook test UI
          console.log('Loading webhook test UI...');
          google.script.run
            .withSuccessHandler(function(html) {
              console.log('Received webhook test UI HTML:', html ? 'HTML received' : 'Empty HTML');
              
              // Create a modal for the webhook test UI
              const modal = document.createElement('div');
              modal.id = 'webhook-test-modal';
              modal.className = 'modal';
              
              // Create modal content
              const modalContent = document.createElement('div');
              modalContent.className = 'modal-content';
              modalContent.style.maxWidth = '800px';
              modalContent.style.maxHeight = '90vh';
              modalContent.style.overflow = 'auto';
              
              // Add close button
              const closeBtn = document.createElement('span');
              closeBtn.className = 'close-modal';
              closeBtn.innerHTML = '&times;';
              closeBtn.onclick = function() {
                console.log('Closing webhook test modal');
                modal.remove();
              };
              
              // Add content
              modalContent.appendChild(closeBtn);
              
              // Check if we got valid HTML
              if (html && typeof html === 'string' && html.trim() !== '') {
                modalContent.insertAdjacentHTML('beforeend', html);
                
                // Initialize the webhook test UI
                try {
                  console.log('Initializing webhook test UI');
                  // The WebhookTestUI.html has its own initialization code
                } catch (e) {
                  console.error('Error initializing webhook test UI:', e);
                  showToast('Error initializing webhook test UI', 'error');
                }
              } else {
                console.error('Invalid or empty HTML received for webhook test UI');
                modalContent.insertAdjacentHTML('beforeend', 
                  '<h2>Error</h2><p>Could not load webhook test tool. Please try again or check the logs.</p>');
              }
              
              // Add to modal and then to body
              modal.appendChild(modalContent);
              document.body.appendChild(modal);
              
              // Show the modal
              modal.style.display = 'block';
              console.log('Webhook test modal displayed');
              
              // Close modal when clicking outside
              modal.onclick = function(event) {
                if (event.target === modal) {
                  console.log('Closing webhook test modal (click outside)');
                  modal.remove();
                }
              };
            })
            .withFailureHandler(function(error) {
              console.error('Error loading webhook test UI:', error);
              showErrorModal('Error loading webhook test UI', error);
            })
            .showWebhookTestUI();
        })
        .withFailureHandler(function(error) {
          console.error('Server connection test failed:', error);
          showErrorModal('Could not connect to server', error);
        })
        .testClientServerCommunication();
    }
    
    // Helper function to show error modal
    function showErrorModal(title, error) {
      let errorMessage = title;
      
      if (error && error.message) {
        errorMessage += ': ' + error.message;
      }
      
      showToast(errorMessage, 'error');
      
      // Create a fallback modal with the error
      const modal = document.createElement('div');
      modal.id = 'webhook-test-error-modal';
      modal.className = 'modal';
      modal.style.display = 'block';
      
      const modalContent = document.createElement('div');
      modalContent.className = 'modal-content';
      modalContent.style.maxWidth = '600px';
      modalContent.innerHTML = `
        <span class="close-modal" onclick="this.closest('.modal').remove()">&times;</span>
        <h2>${title}</h2>
        <p>${errorMessage}</p>
        <p>Please check the browser console for more details.</p>
        <div class="button-group" style="margin-top: 20px;">
          <button class="secondary-btn" onclick="this.closest('.modal').remove()">Close</button>
        </div>
      `;
      
      modal.appendChild(modalContent);
      document.body.appendChild(modal);
      
      // Close on outside click
      modal.onclick = function(event) {
        if (event.target === modal) {
          modal.remove();
        }
      };
    }
    
    // Show toast notification
    function showToast(message, type = 'info') {
      const toast = document.createElement('div');
      toast.className = `toast toast-${type}`;
      toast.textContent = message;
      document.body.appendChild(toast);
      
      // Auto-remove after 3 seconds
      setTimeout(() => {
        toast.classList.add('fade-out');
        setTimeout(() => {
          toast.remove();
        }, 300);
      }, 3000);
    }
    
    // Load users table
    function loadUsers() {
      showSpinner('Loading users...');
      google.script.run
        .withSuccessHandler(function(users) {
          renderUsersTable(users);
          hideSpinner();
        })
        .withFailureHandler(function(error) {
          console.error('Error loading users:', error);
          const errorMsg = error.message || 'Unknown error loading users';
          if (errorMsg.includes('Access denied') || errorMsg.includes('Admin privileges required')) {
            // Don't show error toast for unauthorized access, just hide the admin tab
            console.log('User does not have permission to view users');
            const adminTab = document.getElementById('admin-tab');
            if (adminTab) adminTab.style.display = 'none';
          } else {
            showToast('Error loading users: ' + errorMsg, 'error');
          }
          hideSpinner();
        })
        .getUsers();
    }
    
    // Render users table
    function renderUsersTable(users) {
      const tbody = document.getElementById('users-table-body');
      if (!tbody) return;
      
      tbody.innerHTML = '';
      users.forEach(user => {
        if (!user.isGroup) { // Only show actual users, not groups
          const row = document.createElement('tr');
          const email = user.email || user.Email || '';
          const name = user.name || user.displayName || 
                     (user.firstName && user.lastName ? `${user.firstName} ${user.lastName}`.trim() : 
                     email ? email.split('@')[0] : 'N/A');
          
          row.innerHTML = `
            <td>${name}</td>
            <td>${email || 'N/A'}</td>
            <td>${(user.role || 'user').toLowerCase()}</td>
            <td>
              <button class="action-btn edit-btn" onclick="editUser('${email}')">Edit</button>
              <button class="action-btn delete-btn" onclick="deleteUser('${email}')">Delete</button>
            </td>
          `;
          tbody.appendChild(row);
        }
      });
    }
    
    // Load groups table
    function loadGroups() {
      showSpinner('Loading groups...');
      google.script.run
        .withSuccessHandler(function(groups) {
          renderGroupsTable(groups);
          hideSpinner();
        })
        .withFailureHandler(function(error) {
          console.error('Error loading groups:', error);
          const errorMsg = error.message || 'Unknown error loading groups';
          if (errorMsg.includes('Access denied') || errorMsg.includes('Admin privileges required')) {
            // Don't show error toast for unauthorized access, just hide the admin tab
            console.log('User does not have permission to view groups');
            const adminTab = document.getElementById('admin-tab');
            if (adminTab) adminTab.style.display = 'none';
          } else {
            showToast('Error loading groups: ' + errorMsg, 'error');
          }
          hideSpinner();
        })
        .getNotificationGroups();
    }
    
    // Render groups table
    function renderGroupsTable(groups) {
      const tbody = document.getElementById('groups-table-body');
      if (!tbody) return;
      
      tbody.innerHTML = '';
      groups.forEach(group => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${group.groupName}</td>
          <td>${group.groupId}</td>
          <td>${group.webhookUrl ? group.webhookUrl.substring(0, 50) + '...' : 'Not set'}</td>
          <td>
            <button class="action-btn edit-btn" onclick="editGroup('${group.groupName}')">Edit</button>
            <button class="action-btn delete-btn" onclick="deleteGroup('${group.groupName}')">Delete</button>
          </td>
        `;
        tbody.appendChild(row);
      });
    }
    
    // Load memberships table
    function loadMemberships() {
      showSpinner('Loading memberships...');
      google.script.run
        .withSuccessHandler(function(memberships) {
          renderMembershipsTable(memberships);
          hideSpinner();
        })
        .withFailureHandler(function(error) {
          console.error('Error loading memberships:', error);
          hideSpinner();
          alert('Error loading memberships: ' + error);
        })
        .getGroupMemberships();
    }
    
    // Render memberships table
    function renderMembershipsTable(memberships) {
      const tbody = document.getElementById('memberships-table-body');
      if (!tbody) return;
      
      tbody.innerHTML = '';
      memberships.forEach(membership => {
        const row = document.createElement('tr');
        row.innerHTML = `
          <td>${membership.userEmail}</td>
          <td>${membership.groupName}</td>
          <td>
            <button class="action-btn delete-btn" onclick="deleteMembership('${membership.userEmail}', '${membership.groupName}')">Remove</button>
          </td>
        `;
        tbody.appendChild(row);
      });
    }
    
    // Show add user modal
    function showAddUserModal() {
      const name = prompt('Enter user name:');
      if (!name) return;
      
      const email = prompt('Enter user email:');
      if (!email) return;
      
      const role = prompt('Enter user role (admin, provider, staff, user):', 'user');
      if (!role) return;
      
      addUser(name, email, role);
    }
    
    // Add user
    function addUser(name, email, role) {
      showSpinner('Adding user...');
      google.script.run
        .withSuccessHandler(function(result) {
          hideSpinner();
          alert('User added successfully!');
          loadUsers();
        })
        .withFailureHandler(function(error) {
          console.error('Error adding user:', error);
          hideSpinner();
          alert('Error adding user: ' + error);
        })
        .addUser(name, email, role);
    }
    
    // Edit user
    function editUser(email) {
      console.log('editUser called with email:', email);
      showSpinner('Loading user data...');
      
      // Fetch the user data directly from the server
      google.script.run
        .withSuccessHandler(function(user) {
          hideSpinner();
          if (user) {
            console.log('User data loaded:', user);
            showUserModal(true, user);
          } else {
            alert('User not found');
          }
        })
        .withFailureHandler(function(error) {
          hideSpinner();
          console.error('Error loading user:', error);
          alert('Error loading user: ' + error.message);
        })
        .getUserByEmail(email);
    }
    
    // Update user
    function updateUser(email, name, role) {
      showSpinner('Updating user...');
      google.script.run
        .withSuccessHandler(function(result) {
          hideSpinner();
          alert('User updated successfully!');
          loadUsers();
        })
        .withFailureHandler(function(error) {
          console.error('Error updating user:', error);
          hideSpinner();
          alert('Error updating user: ' + error);
        })
        .updateUser(email, name, role);
    }
    
    // Delete user
    function deleteUser(email, name = '') {
      // Show confirmation modal
      showConfirmModal(
        `Are you sure you want to delete ${name ? `user <strong>${name}</strong> (${email})` : 'this user'}? This action cannot be undone.`,
        function() {
          // This function runs when user confirms
          showSpinner('Deleting user...');
          google.script.run
            .withSuccessHandler(function(result) {
              hideSpinner();
              showToast('User deleted successfully!', 'success');
              loadUsers();
            })
            .withFailureHandler(function(error) {
              console.error('Error deleting user:', error);
              hideSpinner();
              showErrorModal('Error Deleting User', error);
            })
            .deleteUser(email);
        }
      );
    }
    
    // Show add group modal
    function showAddGroupModal() {
      const groupName = prompt('Enter group name:');
      if (!groupName) return;
      
      const groupId = prompt('Enter group ID:');
      if (!groupId) return;
      
      const webhookUrl = prompt('Enter webhook URL (optional):') || '';
      
      addGroup(groupName, groupId, webhookUrl);
    }
    
    // Add group
    function addGroup(groupName, groupId, webhookUrl) {
      showSpinner('Adding group...');
      google.script.run
        .withSuccessHandler(function(result) {
          hideSpinner();
          alert('Group added successfully!');
          loadGroups();
        })
        .withFailureHandler(function(error) {
          console.error('Error adding group:', error);
          hideSpinner();
          alert('Error adding group: ' + error);
        })
        .addNotificationGroup(groupName, groupId, webhookUrl);
    }
    
    // Edit group
    function editGroup(groupName) {
      const newGroupId = prompt('Enter new group ID:');
      if (newGroupId === null) return;
      
      const newWebhookUrl = prompt('Enter new webhook URL:') || '';
      
      updateGroup(groupName, newGroupId, newWebhookUrl);
    }
    
    // Update group
    function updateGroup(groupName, groupId, webhookUrl) {
      showSpinner('Updating group...');
      google.script.run
        .withSuccessHandler(function(result) {
          hideSpinner();
          alert('Group updated successfully!');
          loadGroups();
        })
        .withFailureHandler(function(error) {
          console.error('Error updating group:', error);
          hideSpinner();
          alert('Error updating group: ' + error);
        })
        .updateNotificationGroup(groupName, groupId, webhookUrl);
    }
    
    // Delete group
    function deleteGroup(groupName, groupId = '') {
      // Show confirmation modal
      showConfirmModal(
        `Are you sure you want to delete the group <strong>${groupName}</strong>${groupId ? ` (${groupId})` : ''}? This action cannot be undone and will remove all group memberships.`,
        function() {
          // This function runs when user confirms
          showSpinner('Deleting group...');
          google.script.run
            .withSuccessHandler(function(result) {
              hideSpinner();
              showToast('Group deleted successfully!', 'success');
              loadGroups();
              loadMemberships(); // Refresh memberships as they may be affected
            })
            .withFailureHandler(function(error) {
              console.error('Error deleting group:', error);
              hideSpinner();
              showErrorModal('Error Deleting Group', error);
            })
            .deleteNotificationGroup(groupName);
        }
      );
    }
    
    // Show add membership modal
    function showAddMembershipModal() {
      // Create modal HTML
      const modalHtml = `
        <div class="modal fade" id="addMembershipModal" tabindex="-1" aria-labelledby="addMembershipModalLabel" aria-hidden="true">
          <div class="modal-dialog">
            <div class="modal-content">
              <div class="modal-header">
                <h5 class="modal-title" id="addMembershipModalLabel">Add New Membership</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
              </div>
              <div class="modal-body">
                <form id="addMembershipForm">
                  <div class="mb-3">
                    <label for="userEmail" class="form-label">User</label>
                    <select class="form-select" id="userEmail" required>
                      <option value="" selected disabled>Select a user...</option>
                    </select>
                  </div>
                  <div class="mb-3">
                    <label for="groupName" class="form-label">Group</label>
                    <select class="form-select" id="groupName" required>
                      <option value="" selected disabled>Select a group...</option>
                    </select>
                  </div>
                </form>
                <div id="membershipError" class="alert alert-danger d-none" role="alert"></div>
              </div>
              <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="saveMembershipBtn">
                  <span class="spinner-border spinner-border-sm d-none" role="status" aria-hidden="true" id="membershipSpinner"></span>
                  Save Membership
                </button>
              </div>
            </div>
          </div>
        </div>
      `;
      
      // Add modal to DOM if not already there
      if (!document.getElementById('addMembershipModal')) {
        document.body.insertAdjacentHTML('beforeend', modalHtml);
      }
      
      // Initialize modal
      const modal = new bootstrap.Modal(document.getElementById('addMembershipModal'));
      const userSelect = document.getElementById('userEmail');
      const groupSelect = document.getElementById('groupName');
      const errorDiv = document.getElementById('membershipError');
      const saveBtn = document.getElementById('saveMembershipBtn');
      const spinner = document.getElementById('membershipSpinner');
      
      // Clear form and error
      const addMembershipForm = document.getElementById('addMembershipForm');
      if (addMembershipForm) addMembershipForm.reset();
      errorDiv.classList.add('d-none');
      
      // Show loading state
      function setLoading(isLoading) {
        if (isLoading) {
          saveBtn.disabled = true;
          spinner.classList.remove('d-none');
        } else {
          saveBtn.disabled = false;
          spinner.classList.add('d-none');
        }
      }
      
      // Show error message
      function showError(message) {
        errorDiv.textContent = message;
        errorDiv.classList.remove('d-none');
      }
      
      // Load users into dropdown
      function loadUsers() {
        setLoading(true);
        google.script.run
          .withSuccessHandler(function(users) {
            userSelect.innerHTML = '<option value="" selected disabled>Select a user...</option>';
            users.forEach(user => {
              const option = document.createElement('option');
              option.value = user.email;
              option.textContent = `${user.name} (${user.email})`;
              userSelect.appendChild(option);
            });
            setLoading(false);
          })
          .withFailureHandler(function(error) {
            console.error('Error loading users:', error);
            showError('Failed to load users. Please try again.');
            setLoading(false);
          })
          .getUsers();
      }
      
      // Load groups into dropdown
      function loadGroups() {
        setLoading(true);
        google.script.run
          .withSuccessHandler(function(groups) {
            groupSelect.innerHTML = '<option value="" selected disabled>Select a group...</option>';
            groups.forEach(group => {
              const option = document.createElement('option');
              option.value = group.name;
              option.textContent = group.name;
              groupSelect.appendChild(option);
            });
            setLoading(false);
          })
          .withFailureHandler(function(error) {
            console.error('Error loading groups:', error);
            showError('Failed to load groups. Please try again.');
            setLoading(false);
          })
          .getNotificationGroups();
      }
      
      // Handle save button click
      function handleSaveMembership() {
        const userEmail = userSelect.value;
        const groupName = groupSelect.value;
        
        if (!userEmail || !groupName) {
          showError('Please select both a user and a group');
          return;
        }
        
        // Show loading state
        setLoading(true);
        errorDiv.classList.add('d-none');
        
        // Add membership
        addMembership(userEmail, groupName);
      }
      
      // Set up event listeners
      if (saveBtn) {
        saveBtn.removeEventListener('click', handleSaveMembership);
        saveBtn.addEventListener('click', handleSaveMembership);
      }
      
      // Load data and show modal
      Promise.all([
        new Promise(resolve => loadUsers()),
        new Promise(resolve => loadGroups())
      ]).then(() => {
        modal.show();
      });
    }
    
    // Add membership
    function addMembership(userEmail, groupName) {
      const modal = bootstrap.Modal.getInstance(document.getElementById('addMembershipModal'));
      const errorDiv = document.getElementById('membershipError');
      const saveBtn = document.getElementById('saveMembershipBtn');
      const spinner = document.getElementById('membershipSpinner');
      
      // Show loading state
      saveBtn.disabled = true;
      spinner.classList.remove('d-none');
      errorDiv.classList.add('d-none');
      
      google.script.run
        .withSuccessHandler(function(result) {
          // Hide spinner and re-enable button
          saveBtn.disabled = false;
          spinner.classList.add('d-none');
          
          // Show success message
          showToast('Membership added successfully!', 'success');
          
          // Close modal
          if (modal) modal.hide();
          
          // Refresh memberships list
          loadMemberships();
        })
        .withFailureHandler(function(error) {
          console.error('Error adding membership:', error);
          
          // Hide spinner and re-enable button
          saveBtn.disabled = false;
          spinner.classList.add('d-none');
          
          // Show error in modal
          if (errorDiv) {
            errorDiv.textContent = 'Error adding membership: ' + (error.message || error);
            errorDiv.classList.remove('d-none');
            
            // Scroll to error
            errorDiv.scrollIntoView({ behavior: 'smooth', block: 'center' });
          } else {
            // Fallback to alert if modal is not available
            alert('Error adding membership: ' + (error.message || error));
          }
        })
        .addGroupMembership(userEmail, groupName);
    }
    
    // Delete membership
    function deleteMembership(userEmail, groupName) {
      if (!confirm('Are you sure you want to remove this membership?')) return;
      
      showSpinner('Removing membership...');
      google.script.run
        .withSuccessHandler(function(result) {
          hideSpinner();
          alert('Membership removed successfully!');
          loadMemberships();
        })
        .withFailureHandler(function(error) {
          console.error('Error removing membership:', error);
          hideSpinner();
          alert('Error removing membership: ' + error);
        })
        .removeGroupMembership(userEmail, groupName);
    }
    
    // Duplicate admin tab event listeners removed - handled in main initTabs function
    
    // Debug Leo webhook function
    function debugLeoWebhookTest() {
      console.log('Debugging Leo webhook...');
      google.script.run
        .withSuccessHandler(function(result) {
          console.log('Leo webhook debug result:', result);
          alert(`Leo Webhook Debug Results:\n\n` +
                `Leo Found: ${result.leoFound}\n` +
                `Leo Email: ${result.leoEmail || 'Not found'}\n` +
                `Has Webhook: ${result.hasWebhook}\n` +
                `Total Users: ${result.totalUsers}\n\n` +
                `Check console and logs for detailed information.`);
        })
        .withFailureHandler(function(error) {
          console.error('Leo webhook debug failed:', error);
          alert('Leo webhook debug failed: ' + error.message);
        })
        .debugLeoWebhook();
    }

</script>